{"version":3,"file":"racoon.min.js","sources":["../lib/utils/is.js","../lib/utils/constants.js","../lib/utils/validate-error.js","../lib/restricts/base.js","../lib/restricts/number-type.js","../lib/restricts/number-required.js","../lib/restricts/enum.js","../lib/restricts/number-max.js","../lib/restricts/number-min.js","../lib/restricts/number-int.js","../lib/restricts/required.js","../lib/restricts/custom.js","../lib/type/base.js","../lib/type/number.js","../lib/restricts/string-type.js","../lib/restricts/length-max.js","../lib/restricts/length-min.js","../lib/restricts/string-pattern.js","../lib/type/string.js","../lib/restricts/boolean-type.js","../lib/type/boolean.js","../lib/restricts/any-type.js","../lib/restricts/any-required.js","../lib/type/any.js","../lib/restricts/object-type.js","../lib/type/object.js","../lib/restricts/array-type.js","../lib/type/arrary.js","../lib/index.js"],"sourcesContent":["export const toString = Object.prototype.toString;\n\nexport function getType(val) {\n  const str = toString.call(val);\n  return str.substring(8, str.length - 1);\n}\n\nexport function isUndefined(val) {\n  return getType(val) === 'Undefined';\n}\n\nexport function isNull(val) {\n  return val === null;\n}\n\nexport function isNaN(val) {\n  return val !== val;\n}\n\nexport function isNotRequired(val) {\n  return isUndefined(val) || isNull(val);\n}\n\nexport function isFalsy(val) {\n  return !val;\n}\n\nexport function isEmpty(val) {\n  const type = getType(val);\n  if (type === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n  if (type === 'Array' || type === 'Arguments') {\n    return val.length === 0;\n  }\n  return isFalsy(val);\n}\n\nexport function isEmptyObject(val) {\n  if (getType(val) === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n  return false;\n}\n\nexport function isEmptyArray(val) {\n  if (getType(val) === 'Array') {\n    return val.length === 0;\n  }\n  return false;\n}\n\nexport function isString(val) {\n  return typeof val === 'string';\n}\n\nexport function isNumber(val) {\n  return typeof val === 'number';\n}\n\nexport function isInt(val) {\n  if (isNumber(val) === false) {\n    return false;\n  }\n  return Math.floor(val) === val;\n}\n\nexport function isInfinity(val) {\n  return isNumber(val) && isNaN(val) === false && Number.isFinite(val) === false;\n}\n\nexport function isBoolean(val) {\n  return typeof val === 'boolean';\n}\n\nexport function isRegExp(val) {\n  return val instanceof RegExp;\n}\n\nexport function isObject(val) {\n  return getType(val) === 'Object';\n}\n\nexport function isArray(val) {\n  return Array.isArray(val);\n}\n\nexport function isFunction(val) {\n  return getType(val) === 'Function';\n}\n\nexport function getKeyStr(keyChain) {\n  const propReg = /^[_$a-z][_$a-z\\d]*$/i;\n  let result = '';\n  for (let i = 0; i < keyChain.length; i += 1) {\n    const { type, key } = keyChain[i];\n    if (type === 'prop' && propReg.test(key)) {\n      if (result) {\n        result += `.${key}`;\n      } else {\n        result += key;\n      }\n    } else if (type === 'prop') {\n      result += `['${key}']`;\n    } else if (type === 'index') {\n      result += `[${key}]`;\n    }\n  }\n  return result;\n}\n","export const TYPE = {\n  number: 'number',\n  string: 'string',\n  boolean: 'boolean',\n  object: 'object',\n  array: 'array',\n  any: 'any'\n};\n","export default class ValidateError extends Error {\n  toString() {\n    return `Validate${super.toString()}`;\n  }\n}\n","import { isFunction } from '../utils/is';\nimport ValidateError from '../utils/validate-error';\n\nexport default class RestrictBase {\n  errorConfig = {\n    message: '',\n    ctx: null\n  }\n\n  setErrorMessage(message, ctx) {\n    this.errorConfig = {\n      message,\n      ctx,\n    };\n  }\n\n  getError(originMessage) {\n    const { message, ctx } = this.errorConfig;\n    if (isFunction(message)) {\n      return new ValidateError(\n        message.call(ctx, originMessage)\n      );\n    }\n    return new ValidateError(message || originMessage);\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isNaN,\n  isNumber,\n  isUndefined,\n  isNull,\n  isInfinity\n} from '../utils/is';\n\nexport default class RestrictNumberType extends RestrictBase {\n  isAllowNaN = false;\n  isAllowInfinity = false;\n\n  enableAllowNaN() {\n    this.isAllowNaN = true;\n  }\n\n  enableAllowInfinity() {\n    this.isAllowInfinity = true;\n  }\n\n  validate(val) {\n    const { isAllowNaN, isAllowInfinity } = this;\n    if (isNaN(val) && isAllowNaN === false) {\n      throw this.getError('value is not allowed to be NaN');\n    }\n    if (isInfinity(val) && isAllowInfinity === false) {\n      throw this.getError('value is not allowed to be Infinity');\n    }\n    if (isNumber(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof number');\n  }\n}\n","import RestrictBase from './base';\nimport { isNaN, isNotRequired } from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  validate(val) {\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n    if (isNaN(val)) {\n      throw this.getError('value is required and should not be NaN');\n    }\n    return true;\n  }\n}\n","import RestrictBase from './base';\n\nexport default class RestrictEnum extends RestrictBase {\n  enumValues = null;\n\n  constructor(...values) {\n    super();\n    if (values.length === 0) {\n      throw new RangeError('enum arguments can not be empty');\n    }\n    this.enumValues = values;\n  }\n\n  get valueStr() {\n    return JSON.stringify(this.enumValues);\n  }\n\n  validate(val) {\n    if (this.enumValues.indexOf(val) > -1) {\n      return true;\n    }\n    throw this.getError(`value should be one of ${this.valueStr}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictNumberMax extends RestrictBase {\n  constructor(max, closed) {\n    super();\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be typeof number');\n    }\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed === false) {\n      if (val < this.max) {\n        return true;\n      }\n      throw this.getError(`value should less than ${this.max}`);\n    }\n\n    if (val <= this.max) {\n      return true;\n    }\n    throw this.getError(`value should less than or equal ${this.max}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictNumberMin extends RestrictBase {\n  constructor(min, closed) {\n    super();\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed === false) {\n      if (val > this.min) {\n        return true;\n      }\n      throw this.getError(`value should greater than ${this.min}`);\n    }\n\n    if (val >= this.min) {\n      return true;\n    }\n    throw this.getError(`value should greater than or equal ${this.min}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isInt } from '../utils/is';\n\nexport default class RestrictNumberInt extends RestrictBase {\n  validate(val) {\n    if (isInt(val)) {\n      return true;\n    }\n    throw this.getError('value should be an int');\n  }\n}\n","import RestrictBase from './base';\nimport { isEmpty, isNotRequired } from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  validate(val) {\n    const { strict } = this;\n    if (strict === true) {\n      if (isEmpty(val)) {\n        throw this.getError('value is required and should not be empty');\n      }\n      return true;\n    }\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n    return true;\n  }\n}\n","import { isFunction } from '../utils/is';\nimport RestrictBase from './base';\n\nexport default class RestrictCustom extends RestrictBase {\n  constructor(restrictFn, ctx) {\n    super();\n    if (isFunction(restrictFn) === false) {\n      throw new TypeError('`custom` must receive a Function parameter');\n    }\n    this.restrictFn = restrictFn;\n    this.ctx = ctx;\n  }\n\n  validate(val) {\n    try {\n      this.restrictFn.call(this.ctx, val);\n    } catch (error) {\n      throw this.getError(error.message);\n    }\n    return true;\n  }\n}\n","import {\n  isEmpty,\n  isNotRequired,\n  isNaN\n} from '../utils/is';\nimport RestrictRequired from '../restricts/required';\nimport RestrictCustom from '../restricts/custom';\n\nexport default class TypeBase {\n  restricts = [];\n  typeRestrict = null;\n  requiredRestrict = null;\n  currentRestrict = null;\n  defaultConfig = {\n    enable: false,\n    strict: false,\n    value: undefined\n  };\n  formatterConfig = {\n    ctx: undefined,\n    formatter: val => val\n  };\n\n  required(strict = false) {\n    this.requiredRestrict = new RestrictRequired(strict);\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  custom(restrictFn, ctx) {\n    const restrict = new RestrictCustom(restrictFn, ctx);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  error(message, ctx) {\n    this.currentRestrict.setErrorMessage(message, ctx);\n    return this;\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, strict, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: strict === true,\n      value,\n      ctx\n    });\n    return this;\n  }\n\n  format(formatter, ctx) {\n    if (typeof formatter !== 'function') {\n      throw new TypeError('`format` argument should be a function');\n    }\n    this.formatterConfig = {\n      ctx,\n      formatter\n    };\n    return this;\n  }\n\n  calcDefaultValue(val) {\n    const { value, ctx } = this.defaultConfig;\n    if (typeof value === 'function') {\n      return value.call(ctx, val);\n    }\n    return value;\n  }\n\n  getReturnValueWithStrict(val) {\n    const { enable, strict } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    if (enable && (isNotRequired(val) || isNaN(val))) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    if (enable && isEmpty(val) && strict) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  getReturnValue(val) {\n    const { formatter, ctx } = this.formatterConfig;\n    if (this.defaultConfig.enable && (isNotRequired(val) || isNaN(val))) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  checkType(val) {\n    return this.typeRestrict.validate(val);\n  }\n\n  checkRequired(val) {\n    if (!this.requiredRestrict) {\n      return true;\n    }\n\n    return this.requiredRestrict.validate(val);\n  }\n\n  checkRestricts(val) {\n    for (let i = 0; i < this.restricts.length; i += 1) {\n      this.restricts[i].validate(val);\n    }\n    return true;\n  }\n\n  validate(val) {\n    if (!this.requiredRestrict && isNotRequired(val)) {\n      return this.getReturnValue(val);\n    }\n    this.checkType(val);\n    this.checkRequired(val);\n    this.checkRestricts(val);\n\n    return this.getReturnValue(val);\n  }\n\n  validateSilent(val) {\n    try {\n      return {\n        value: this.validate(val)\n      };\n    } catch (error) {\n      return {\n        error,\n        value: val\n      };\n    }\n  }\n}\n","import {\n  isNaN,\n  isNotRequired\n} from '../utils/is';\nimport { TYPE } from '../utils/constants';\nimport RestrictNumberType from '../restricts/number-type';\nimport RestrictNumberRequired from '../restricts/number-required';\nimport RestrictEnum from '../restricts/enum';\nimport RestrictNumberMax from '../restricts/number-max';\nimport RestrictNumberMin from '../restricts/number-min';\nimport RestrictNumberInt from '../restricts/number-int';\nimport TypeBase from './base';\n\nexport default class TypeNumber extends TypeBase {\n  type = TYPE.number;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictNumberType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    const { enable } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    if (\n      enable\n      && (isNotRequired(val) || isNaN(val))\n    ) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: false,\n      value,\n      ctx\n    });\n    return this;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  required() {\n    this.requiredRestrict = new RestrictNumberRequired();\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  allowNaN() {\n    this.typeRestrict.enableAllowNaN();\n    return this;\n  }\n\n  allowInfinity() {\n    this.typeRestrict.enableAllowInfinity();\n    return this;\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictNumberMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictNumberMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  int() {\n    const restrict = new RestrictNumberInt();\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isString,\n  isNotRequired\n} from '../utils/is';\n\nexport default class RestrictStringType extends RestrictBase {\n  validate(val) {\n    if (isString(val) || isNotRequired(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof string');\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictLengthMax extends RestrictBase {\n  constructor(max, closed) {\n    super();\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be typeof number');\n    }\n\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed) {\n      if (val.length <= this.max) {\n        return true;\n      }\n      throw this.getError(`value length should less than or equal ${this.max}`);\n    }\n    if (val.length < this.max) {\n      return true;\n    }\n    throw this.getError(`value length should less than ${this.max}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictLengthMin extends RestrictBase {\n  constructor(min, closed) {\n    super();\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed) {\n      if (val.length >= this.min) {\n        return true;\n      }\n      throw this.getError(`value length should greater than or equal ${this.min}`);\n    }\n    if (val.length > this.min) {\n      return true;\n    }\n    throw this.getError(`value length should greater than ${this.min}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isRegExp } from '../utils/is';\n\nexport default class RestrictStringPattern extends RestrictBase {\n  constructor(pattern) {\n    super();\n    if (isRegExp(pattern) === false) {\n      throw new TypeError('pattern should be a RegExp');\n    }\n    this.pattern = pattern;\n  }\n\n  validate(val) {\n    if (this.pattern.test(val)) {\n      return true;\n    }\n    throw this.getError(`value should match pattern ${this.pattern.toString()}`);\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictStringType from '../restricts/string-type';\nimport RestrictEnum from '../restricts/enum';\nimport RestrictLengthMax from '../restricts/length-max';\nimport RestrictLengthMin from '../restricts/length-min';\nimport RestrictStringPattern from '../restricts/string-pattern';\nimport TypeBase from './base';\n\nexport default class TypeString extends TypeBase {\n  type = TYPE.string;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictStringType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictLengthMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictLengthMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  pattern(pattern) {\n    const restrict = new RestrictStringPattern(pattern);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isBoolean,\n  isNotRequired\n} from '../utils/is';\n\nexport default class RestrictBooleanType extends RestrictBase {\n  validate(val) {\n    if (isBoolean(val) || isNotRequired(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof boolean');\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictBooleanType from '../restricts/boolean-type';\nimport RestrictEnum from '../restricts/enum';\nimport TypeBase from './base';\n\nexport default class TypeBoolean extends TypeBase {\n  type = TYPE;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictBooleanType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: false,\n      value,\n      ctx\n    });\n    return this;\n  }\n}\n","import RestrictBase from './base';\n\nexport default class RestrictAnyType extends RestrictBase {\n  validate(val) {\n    return true;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isNaN,\n  isNotRequired,\n  isEmptyObject,\n  isEmptyArray\n} from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  validate(val) {\n    const { strict } = this;\n    if (strict === true) {\n      if (\n        isNotRequired(val)\n        || val === ''\n        || isNaN(val)\n        || isEmptyObject(val)\n        || isEmptyArray(val)\n      ) {\n        throw this.getError('value is required and should not be empty');\n      }\n      return true;\n    }\n    if (isNotRequired(val) || isNaN(val)) {\n      throw this.getError('value is required and should not be undefined/null/NaN');\n    }\n    return true;\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictAnyType from '../restricts/any-type';\nimport RestrictAnyRequired from '../restricts/any-required';\nimport RestrictEnum from '../restricts/enum';\nimport TypeBase from './base';\n\nexport default class TypeAny extends TypeBase {\n  type = TYPE.any;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictAnyType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  required(strict = false) {\n    this.requiredRestrict = new RestrictAnyRequired(strict);\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isObject,\n  isUndefined,\n  isNull\n} from '../utils/is';\n\nexport default class RestrictObjectType extends RestrictBase {\n  validate(val) {\n    if (isObject(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof object');\n  }\n}\n","import {\n  isObject,\n  isNotRequired,\n  getKeyStr,\n} from '../utils/is';\nimport { TYPE } from '../utils/constants';\nimport RestrictObjectType from '../restricts/object-type';\nimport ValidateError from '../utils/validate-error';\nimport TypeBase from './base';\n\nexport default class TypeObject extends TypeBase {\n  type = TYPE.object;\n  config = null;\n  isStripUnknown = false;\n  isAllowUnknown = false;\n\n  constructor(config) {\n    super();\n    this.typeRestrict = new RestrictObjectType();\n    this.currentRestrict = this.typeRestrict;\n    if (isObject(config)) {\n      const pureConfig = Object.create(null);\n      Object.keys(config).forEach(key => {\n        if (config[key] instanceof TypeBase) {\n          pureConfig[key] = config[key];\n        }\n      });\n      this.config = pureConfig;\n    }\n  }\n\n  get keys() {\n    return Object.keys(this.config);\n  }\n\n  hasKey(key) {\n    return this.keys.includes(key);\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  stripUnknown() {\n    this.isStripUnknown = true;\n    return this;\n  }\n\n  allowUnknown() {\n    this.isAllowUnknown = true;\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {Object} obj - object to validate\n   * @param {Array} [keyChain=[]] - object props chain\n   * @returns {Object} - result of validate\n   */\n  validateRecurse(obj, keyChain) {\n    keyChain = keyChain || [];\n\n    if (this.config === null) {\n      return obj;\n    }\n\n    const result = {};\n    let keys;\n    if (this.isStripUnknown === true) {\n      keys = this.keys;\n    } else {\n      keys = Object.keys(obj);\n    }\n    for (let i = 0; i < keys.length; i += 1) {\n      const key = keys[i];\n      const schema = this.config[key];\n      if (this.hasKey(key) === false) {\n        if (this.isAllowUnknown === true) {\n          result[key] = obj[key];\n          continue;\n        }\n        throw new ValidateError(`the key \\`${key}\\` is not allowed`);\n      }\n\n      try {\n        if (schema.type === TYPE.object || schema.type === TYPE.array) {\n          result[key] = schema.validateRecurse(\n            obj[key],\n            [\n              ...keyChain,\n              {\n                key,\n                type: 'prop'\n              }\n            ]\n          );\n        } else {\n          result[key] = schema.validate(obj[key]);\n        }\n      } catch (error) {\n        if (error instanceof ValidateError) {\n          let keyChainStr = getKeyStr([...keyChain, { type: 'prop', key }]);\n          keyChainStr = `\"${keyChainStr}\": `;\n          throw new Error(`${keyChainStr}${error.message}`);\n        } else {\n          throw error;\n        }\n      }\n    }\n    return result;\n  }\n\n  validate(obj) {\n    if (!this.requiredRestrict && isNotRequired(obj)) {\n      return this.getReturnValue(obj);\n    }\n    this.checkRequired(obj);\n    this.checkType(obj);\n    this.checkRestricts(obj);\n\n    return this.getReturnValue(\n      this.validateRecurse(obj)\n    );\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isArray,\n  isUndefined,\n  isNull\n} from '../utils/is';\n\nexport default class RestrictArrayType extends RestrictBase {\n  validate(val) {\n    if (isArray(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof array');\n  }\n}\n","import {\n  isNotRequired,\n  getKeyStr,\n} from '../utils/is';\nimport ValidateError from '../utils/validate-error';\nimport { TYPE } from '../utils/constants';\nimport RestrictArrayType from '../restricts/array-type';\nimport RestrictLengthMin from '../restricts/length-min';\nimport RestrictLengthMax from '../restricts/length-max';\nimport TypeBase from './base';\n\nexport default class TypeArray extends TypeBase {\n  type = TYPE.array;\n  itemSchema = null;\n\n  constructor(itemSchema) {\n    super();\n    this.typeRestrict = new RestrictArrayType();\n    this.currentRestrict = this.typeRestrict;\n    if (itemSchema instanceof TypeBase) {\n      this.itemSchema = itemSchema;\n    }\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictLengthMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictLengthMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {Array} array - array to validate\n   * @param {Array} [keyChain=[]] - props key chain\n   * @returns {Array} - result of validate\n   */\n  validateRecurse(array, keyChain) {\n    keyChain = keyChain || [];\n    const { itemSchema } = this;\n\n    if (itemSchema) {\n      const result = [];\n      for (let i = 0; i < array.length; i += 1) {\n        try {\n          if (itemSchema.type === TYPE.array || itemSchema.type === TYPE.object) {\n            result.push(\n              itemSchema.validateRecurse(array[i], [...keyChain, { type: 'index', key: i }])\n            );\n          } else {\n            result.push(\n              itemSchema.validate(array[i])\n            );\n          }\n        } catch (error) {\n          if (error instanceof ValidateError) {\n            let keyChainStr = getKeyStr([...keyChain, { type: 'index', key: i }]);\n            keyChainStr = `\"${keyChainStr}\": `;\n            throw new Error(`${keyChainStr}${error.message}`);\n          } else {\n            throw error;\n          }\n        }\n      }\n      return result;\n    }\n    return array;\n  }\n\n  validate(array) {\n    if (!this.requiredRestrict && isNotRequired(array)) {\n      return this.getReturnValue(array);\n    }\n    this.checkRequired(array);\n    this.checkType(array);\n    this.checkRestricts(array);\n\n    return this.getReturnValue(\n      this.validateRecurse(array)\n    );\n  }\n}\n","import {\n  TypeNumber,\n  TypeString,\n  TypeBoolean,\n  TypeAny,\n  TypeObject,\n  TypeArray\n} from './type';\n\nexport function number() {\n  return new TypeNumber();\n}\n\nexport function string() {\n  return new TypeString();\n}\n\nexport function boolean() {\n  return new TypeBoolean();\n}\n\nexport function any() {\n  return new TypeAny();\n}\n\nexport function object(config) {\n  return new TypeObject(config);\n}\n\nexport function array(itemSchema) {\n  return new TypeArray(itemSchema);\n}\n\nexport default {\n  number,\n  string,\n  boolean,\n  any,\n  object,\n  array\n};\n"],"names":["toString","Object","prototype","getType","val","str","call","substring","length","isUndefined","isNull","isNaN","isNotRequired","isEmpty","type","keys","isFalsy","isNumber","isObject","isFunction","getKeyStr","keyChain","propReg","result","i","key","test","TYPE","number","string","object","array","any","ValidateError","Error","RestrictBase","errorConfig","message","ctx","originMessage","this","RestrictNumberType","isAllowNaN","isAllowInfinity","getError","Number","isFinite","isInfinity","RestrictRequired","RestrictEnum","enumValues","values","RangeError","indexOf","valueStr","JSON","stringify","RestrictNumberMax","max","closed","TypeError","RestrictNumberMin","min","RestrictNumberInt","Math","floor","isInt","strict","RestrictCustom","restrictFn","error","TypeBase","restricts","typeRestrict","requiredRestrict","currentRestrict","defaultConfig","enable","value","undefined","formatterConfig","formatter","restrict","push","setErrorMessage","args","assign","calcDefaultValue","validate","checkType","checkRequired","checkRestricts","getReturnValue","TypeNumber","_this","RestrictNumberRequired","enableAllowNaN","enableAllowInfinity","RestrictStringType","isString","RestrictLengthMax","RestrictLengthMin","RestrictStringPattern","pattern","RegExp","TypeString","getReturnValueWithStrict","RestrictBooleanType","isBoolean","TypeBoolean","RestrictAnyType","isEmptyObject","isEmptyArray","TypeAny","RestrictAnyRequired","RestrictObjectType","TypeObject","config","isStripUnknown","isAllowUnknown","pureConfig","create","forEach","includes","obj","schema","hasKey","validateRecurse","keyChainStr","RestrictArrayType","Array","isArray","TypeArray","itemSchema","boolean"],"mappings":"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"}