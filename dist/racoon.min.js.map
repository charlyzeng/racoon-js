{"version":3,"file":"racoon.min.js","sources":["../lib/utils/is.js","../lib/utils/constants.js","../lib/utils/validate-error.js","../lib/restricts/base.js","../lib/restricts/number-type.js","../lib/restricts/number-required.js","../lib/restricts/enum.js","../lib/restricts/number-max.js","../lib/restricts/number-min.js","../lib/restricts/number-int.js","../lib/restricts/required.js","../lib/restricts/custom.js","../lib/type/base.js","../lib/type/number.js","../lib/restricts/string-type.js","../lib/restricts/length-max.js","../lib/restricts/length-min.js","../lib/restricts/string-pattern.js","../lib/type/string.js","../lib/restricts/boolean-type.js","../lib/type/boolean.js","../lib/restricts/any-type.js","../lib/restricts/any-required.js","../lib/type/any.js","../lib/restricts/object-type.js","../lib/type/object.js","../lib/restricts/array-type.js","../lib/type/arrary.js","../lib/index.js"],"sourcesContent":["export const toString = Object.prototype.toString;\n\nexport function getType(val) {\n  const str = toString.call(val);\n  return str.substring(8, str.length - 1);\n}\n\nexport function isUndefined(val) {\n  return getType(val) === 'Undefined';\n}\n\nexport function isNull(val) {\n  return val === null;\n}\n\nexport function isNaN(val) {\n  return val !== val;\n}\n\nexport function isNotRequired(val) {\n  return isUndefined(val) || isNull(val);\n}\n\nexport function isFalsy(val) {\n  return !val;\n}\n\nexport function isEmpty(val) {\n  const type = getType(val);\n  if (type === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n  if (type === 'Array' || type === 'Arguments') {\n    return val.length === 0;\n  }\n  return isFalsy(val);\n}\n\nexport function isEmptyObject(val) {\n  if (getType(val) === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n  return false;\n}\n\nexport function isEmptyArray(val) {\n  if (getType(val) === 'Array') {\n    return val.length === 0;\n  }\n  return false;\n}\n\nexport function isString(val) {\n  return typeof val === 'string';\n}\n\nexport function isNumber(val) {\n  return typeof val === 'number';\n}\n\nexport function isInt(val) {\n  if (isNumber(val) === false) {\n    return false;\n  }\n  return Math.floor(val) === val;\n}\n\nexport function isInfinity(val) {\n  return isNumber(val) && isNaN(val) === false && Number.isFinite(val) === false;\n}\n\nexport function isBoolean(val) {\n  return typeof val === 'boolean';\n}\n\nexport function isRegExp(val) {\n  return val instanceof RegExp;\n}\n\nexport function isObject(val) {\n  return getType(val) === 'Object';\n}\n\nexport function isArray(val) {\n  return Array.isArray(val);\n}\n\nexport function isFunction(val) {\n  return getType(val) === 'Function';\n}\n\nexport function getKeyStr(keyChain) {\n  const propReg = /^[_$a-z][_$a-z\\d]*$/i;\n  let result = '';\n  for (let i = 0; i < keyChain.length; i += 1) {\n    const { type, key } = keyChain[i];\n    if (type === 'prop' && propReg.test(key)) {\n      if (result) {\n        result += `.${key}`;\n      } else {\n        result += key;\n      }\n    } else if (type === 'prop') {\n      result += `['${key}']`;\n    } else if (type === 'index') {\n      result += `[${key}]`;\n    }\n  }\n  return result;\n}\n","export const TYPE = {\n  number: 'number',\n  string: 'string',\n  boolean: 'boolean',\n  object: 'object',\n  array: 'array',\n  any: 'any'\n};\n","export default class ValidateError extends Error {\n  noKeyChain = false;\n  final = false;\n\n  constructor(message, options = {}) {\n    super(message);\n    const {\n      noKeyChain = false,\n      final = false,\n      custom = false\n    } = options;\n    this.noKeyChain = noKeyChain;\n    this.final = final;\n    this.custom = custom;\n  }\n\n  toString() {\n    return `Validate${super.toString()}`;\n  }\n}\n","import { isFunction, isString } from '../utils/is';\nimport ValidateError from '../utils/validate-error';\n\nexport default class RestrictBase {\n  errorConfig = {\n    message: '',\n    ctx: null\n  }\n\n  setErrorMessage(message, ctx) {\n    this.errorConfig = {\n      message,\n      ctx,\n    };\n  }\n\n  getError(originMessage) {\n    const { message, ctx } = this.errorConfig;\n    if (isFunction(message)) {\n      return new ValidateError(\n        message.call(ctx, originMessage),\n        { noKeyChain: true, custom: true }\n      );\n    }\n    if (isString(message) && message) {\n      return new ValidateError(message, { noKeyChain: true, custom: true });\n    }\n    return new ValidateError(originMessage);\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isNaN,\n  isNumber,\n  isUndefined,\n  isNull,\n  isInfinity\n} from '../utils/is';\n\nexport default class RestrictNumberType extends RestrictBase {\n  isAllowNaN = false;\n  isAllowInfinity = false;\n\n  enableAllowNaN() {\n    this.isAllowNaN = true;\n  }\n\n  enableAllowInfinity() {\n    this.isAllowInfinity = true;\n  }\n\n  validate(val) {\n    const { isAllowNaN, isAllowInfinity } = this;\n    if (isNaN(val) && isAllowNaN === false) {\n      throw this.getError('value is not allowed to be NaN');\n    }\n    if (isInfinity(val) && isAllowInfinity === false) {\n      throw this.getError('value is not allowed to be Infinity');\n    }\n    if (isNumber(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof number');\n  }\n}\n","import RestrictBase from './base';\nimport { isNaN, isNotRequired } from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  validate(val) {\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n    if (isNaN(val)) {\n      throw this.getError('value is required and should not be NaN');\n    }\n    return true;\n  }\n}\n","import RestrictBase from './base';\n\nexport default class RestrictEnum extends RestrictBase {\n  enumValues = null;\n\n  constructor(...values) {\n    super();\n    if (values.length === 0) {\n      throw new RangeError('enum arguments can not be empty');\n    }\n    this.enumValues = values;\n  }\n\n  get valueStr() {\n    return JSON.stringify(this.enumValues);\n  }\n\n  validate(val) {\n    if (this.enumValues.indexOf(val) > -1) {\n      return true;\n    }\n    throw this.getError(`value should be one of ${this.valueStr}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictNumberMax extends RestrictBase {\n  constructor(max, closed) {\n    super();\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be typeof number');\n    }\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed === false) {\n      if (val < this.max) {\n        return true;\n      }\n      throw this.getError(`value should less than ${this.max}`);\n    }\n\n    if (val <= this.max) {\n      return true;\n    }\n    throw this.getError(`value should less than or equal ${this.max}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictNumberMin extends RestrictBase {\n  constructor(min, closed) {\n    super();\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed === false) {\n      if (val > this.min) {\n        return true;\n      }\n      throw this.getError(`value should greater than ${this.min}`);\n    }\n\n    if (val >= this.min) {\n      return true;\n    }\n    throw this.getError(`value should greater than or equal ${this.min}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isInt } from '../utils/is';\n\nexport default class RestrictNumberInt extends RestrictBase {\n  validate(val) {\n    if (isInt(val)) {\n      return true;\n    }\n    throw this.getError('value should be an int');\n  }\n}\n","import RestrictBase from './base';\nimport { isEmpty, isNotRequired } from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  validate(val) {\n    const { strict } = this;\n    if (strict === true) {\n      if (isEmpty(val)) {\n        throw this.getError('value is required and should not be empty');\n      }\n      return true;\n    }\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n    return true;\n  }\n}\n","import { isFunction, isString } from '../utils/is';\nimport RestrictBase from './base';\n\nexport default class RestrictCustom extends RestrictBase {\n  constructor(restrictFn, ctx) {\n    super();\n    if (isFunction(restrictFn) === false) {\n      throw new TypeError('`custom` must receive a Function parameter');\n    }\n    this.restrictFn = restrictFn;\n    this.ctx = ctx;\n  }\n\n  validate(val) {\n    try {\n      const result = this.restrictFn.call(this.ctx, val);\n      if (isString(result) && result) {\n        throw this.getError(result);\n      }\n    } catch (error) {\n      throw this.getError(error.message);\n    }\n    return true;\n  }\n}\n","import {\n  isEmpty,\n  isNotRequired,\n  isNaN,\n  isString,\n  isFunction\n} from '../utils/is';\nimport ValidateError from '../utils/validate-error';\nimport RestrictRequired from '../restricts/required';\nimport RestrictCustom from '../restricts/custom';\n\nexport default class TypeBase {\n  restricts = [];\n  typeRestrict = null;\n  requiredRestrict = null;\n  currentRestrict = null;\n  defaultConfig = {\n    enable: false,\n    strict: false,\n    value: undefined\n  };\n  formatterConfig = {\n    ctx: undefined,\n    formatter: val => val\n  };\n  errorForAllConfig = {\n    enable: false,\n    ctx: undefined,\n    message: ''\n  };\n\n  required(strict = false) {\n    this.requiredRestrict = new RestrictRequired(strict);\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  custom(restrictFn, ctx) {\n    const restrict = new RestrictCustom(restrictFn, ctx);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  error(message, ctx) {\n    this.currentRestrict.setErrorMessage(message, ctx);\n    return this;\n  }\n\n  errorForAll(message, ctx) {\n    this.errorForAllConfig = {\n      enable: true,\n      message,\n      ctx\n    };\n    return this;\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, strict, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: strict === true,\n      value,\n      ctx\n    });\n    return this;\n  }\n\n  format(formatter, ctx) {\n    if (typeof formatter !== 'function') {\n      throw new TypeError('`format` argument should be a function');\n    }\n    this.formatterConfig = {\n      ctx,\n      formatter\n    };\n    return this;\n  }\n\n  calcDefaultValue(val) {\n    const { value, ctx } = this.defaultConfig;\n    if (typeof value === 'function') {\n      return value.call(ctx, val);\n    }\n    return value;\n  }\n\n  getReturnValueWithStrict(val) {\n    const { enable, strict } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    if (enable && (isNotRequired(val) || isNaN(val))) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    if (enable && isEmpty(val) && strict) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  getReturnValue(val) {\n    const { formatter, ctx } = this.formatterConfig;\n    if (this.defaultConfig.enable && (isNotRequired(val) || isNaN(val))) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  getErrorForAll(originalMessage) {\n    const {\n      enable,\n      ctx,\n      message\n    } = this.errorForAllConfig;\n    if (enable !== true) {\n      return null;\n    }\n    if (isString(message) && message) {\n      return new ValidateError(message);\n    }\n    if (isFunction(message)) {\n      return new ValidateError(\n        message.call(ctx, originalMessage)\n      );\n    }\n    return null;\n  }\n\n  checkType(val) {\n    return this.typeRestrict.validate(val);\n  }\n\n  checkRequired(val) {\n    if (!this.requiredRestrict) {\n      return true;\n    }\n\n    return this.requiredRestrict.validate(val);\n  }\n\n  checkRestricts(val) {\n    for (let i = 0; i < this.restricts.length; i += 1) {\n      this.restricts[i].validate(val);\n    }\n    return true;\n  }\n\n  validate(val) {\n    if (!this.requiredRestrict && isNotRequired(val)) {\n      return this.getReturnValue(val);\n    }\n    try {\n      this.checkType(val);\n      this.checkRequired(val);\n      this.checkRestricts(val);\n\n      return this.getReturnValue(val);\n    } catch (error) {\n      if (error.custom === true) {\n        throw error;\n      }\n      const errorForAll = this.getErrorForAll(error.message);\n      if (errorForAll) {\n        throw errorForAll;\n      }\n      throw error;\n    }\n  }\n\n  validateSilent(val) {\n    try {\n      return {\n        value: this.validate(val)\n      };\n    } catch (error) {\n      return {\n        error,\n        value: val\n      };\n    }\n  }\n}\n","import {\n  isNaN,\n  isString,\n  isNotRequired\n} from '../utils/is';\nimport { TYPE } from '../utils/constants';\nimport RestrictNumberType from '../restricts/number-type';\nimport RestrictNumberRequired from '../restricts/number-required';\nimport RestrictEnum from '../restricts/enum';\nimport RestrictNumberMax from '../restricts/number-max';\nimport RestrictNumberMin from '../restricts/number-min';\nimport RestrictNumberInt from '../restricts/number-int';\nimport TypeBase from './base';\n\nconst NUMBER_REG = /^[+-]?\\d*\\.?\\d*$/;\n\nexport default class TypeNumber extends TypeBase {\n  type = TYPE.number;\n  isAllowString = false;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictNumberType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    const { enable } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    if (\n      enable\n      && (isNotRequired(val) || isNaN(val))\n    ) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: false,\n      value,\n      ctx\n    });\n    return this;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  required() {\n    this.requiredRestrict = new RestrictNumberRequired();\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  allowNaN() {\n    this.typeRestrict.enableAllowNaN();\n    return this;\n  }\n\n  allowInfinity() {\n    this.typeRestrict.enableAllowInfinity();\n    return this;\n  }\n\n  allowString() {\n    this.isAllowString = true;\n    return this;\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictNumberMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictNumberMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  int() {\n    const restrict = new RestrictNumberInt();\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  validate(val) {\n    if (\n      this.isAllowString\n      && isString(val)\n      && val\n      && NUMBER_REG.test(val)\n    ) {\n      val = Number(val);\n    }\n    return super.validate(val);\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isString,\n  isNotRequired\n} from '../utils/is';\n\nexport default class RestrictStringType extends RestrictBase {\n  validate(val) {\n    if (isString(val) || isNotRequired(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof string');\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictLengthMax extends RestrictBase {\n  constructor(max, closed) {\n    super();\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be typeof number');\n    }\n\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed) {\n      if (val.length <= this.max) {\n        return true;\n      }\n      throw this.getError(`value length should less than or equal ${this.max}`);\n    }\n    if (val.length < this.max) {\n      return true;\n    }\n    throw this.getError(`value length should less than ${this.max}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictLengthMin extends RestrictBase {\n  constructor(min, closed) {\n    super();\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed) {\n      if (val.length >= this.min) {\n        return true;\n      }\n      throw this.getError(`value length should greater than or equal ${this.min}`);\n    }\n    if (val.length > this.min) {\n      return true;\n    }\n    throw this.getError(`value length should greater than ${this.min}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isRegExp } from '../utils/is';\n\nexport default class RestrictStringPattern extends RestrictBase {\n  constructor(pattern) {\n    super();\n    if (isRegExp(pattern) === false) {\n      throw new TypeError('pattern should be a RegExp');\n    }\n    this.pattern = pattern;\n  }\n\n  validate(val) {\n    if (this.pattern.test(val)) {\n      return true;\n    }\n    throw this.getError(`value should match pattern ${this.pattern.toString()}`);\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictStringType from '../restricts/string-type';\nimport RestrictEnum from '../restricts/enum';\nimport RestrictLengthMax from '../restricts/length-max';\nimport RestrictLengthMin from '../restricts/length-min';\nimport RestrictStringPattern from '../restricts/string-pattern';\nimport TypeBase from './base';\n\nexport default class TypeString extends TypeBase {\n  type = TYPE.string;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictStringType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictLengthMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictLengthMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  pattern(pattern) {\n    const restrict = new RestrictStringPattern(pattern);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isBoolean,\n  isNotRequired\n} from '../utils/is';\n\nexport default class RestrictBooleanType extends RestrictBase {\n  validate(val) {\n    if (isBoolean(val) || isNotRequired(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof boolean');\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictBooleanType from '../restricts/boolean-type';\nimport RestrictEnum from '../restricts/enum';\nimport TypeBase from './base';\n\nexport default class TypeBoolean extends TypeBase {\n  type = TYPE;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictBooleanType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: false,\n      value,\n      ctx\n    });\n    return this;\n  }\n}\n","import RestrictBase from './base';\n\nexport default class RestrictAnyType extends RestrictBase {\n  validate(val) {\n    return true;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isNaN,\n  isNotRequired,\n  isEmptyObject,\n  isEmptyArray\n} from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  validate(val) {\n    const { strict } = this;\n    if (strict === true) {\n      if (\n        isNotRequired(val)\n        || val === ''\n        || isNaN(val)\n        || isEmptyObject(val)\n        || isEmptyArray(val)\n      ) {\n        throw this.getError('value is required and should not be empty');\n      }\n      return true;\n    }\n    if (isNotRequired(val) || isNaN(val)) {\n      throw this.getError('value is required and should not be undefined/null/NaN');\n    }\n    return true;\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictAnyType from '../restricts/any-type';\nimport RestrictAnyRequired from '../restricts/any-required';\nimport RestrictEnum from '../restricts/enum';\nimport TypeBase from './base';\n\nexport default class TypeAny extends TypeBase {\n  type = TYPE.any;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictAnyType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  required(strict = false) {\n    this.requiredRestrict = new RestrictAnyRequired(strict);\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isObject,\n  isUndefined,\n  isNull\n} from '../utils/is';\n\nexport default class RestrictObjectType extends RestrictBase {\n  validate(val) {\n    if (isObject(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof object');\n  }\n}\n","import {\n  isObject,\n  isNotRequired,\n  getKeyStr,\n} from '../utils/is';\nimport { TYPE } from '../utils/constants';\nimport RestrictObjectType from '../restricts/object-type';\nimport ValidateError from '../utils/validate-error';\nimport TypeBase from './base';\n\nexport default class TypeObject extends TypeBase {\n  type = TYPE.object;\n  config = null;\n  isStripUnknown = false;\n  isAllowUnknown = false;\n\n  constructor(config) {\n    super();\n    this.typeRestrict = new RestrictObjectType();\n    this.currentRestrict = this.typeRestrict;\n    if (isObject(config)) {\n      const pureConfig = Object.create(null);\n      Object.keys(config).forEach(key => {\n        if (config[key] instanceof TypeBase) {\n          pureConfig[key] = config[key];\n        }\n      });\n      this.config = pureConfig;\n    }\n  }\n\n  get keys() {\n    return Object.keys(this.config);\n  }\n\n  hasKey(key) {\n    return this.keys.includes(key);\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  stripUnknown() {\n    this.isStripUnknown = true;\n    return this;\n  }\n\n  allowUnknown() {\n    this.isAllowUnknown = true;\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {Object} obj - object to validate\n   * @param {Array} [keyChain=[]] - object props chain\n   * @returns {Object} - result of validate\n   */\n  validateRecurse(obj, keyChain) {\n    keyChain = keyChain || [];\n\n    if (this.config === null) {\n      return obj;\n    }\n\n    const result = {};\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i += 1) {\n      const key = keys[i];\n      const schema = this.config[key];\n      if (this.hasKey(key) === false) {\n        if (this.isStripUnknown === true) {\n          continue;\n        }\n        if (this.isAllowUnknown === true) {\n          result[key] = obj[key];\n          continue;\n        }\n        throw new ValidateError(`the key \\`${key}\\` is not allowed`);\n      }\n\n      try {\n        if (schema.type === TYPE.object || schema.type === TYPE.array) {\n          result[key] = schema.validate(\n            obj[key],\n            'USE_KEY_CHAIN',\n            [\n              ...keyChain,\n              {\n                key,\n                type: 'prop'\n              }\n            ]\n          );\n        } else {\n          result[key] = schema.validate(obj[key]);\n        }\n      } catch (error) {\n        if (error.final) {\n          throw error;\n        }\n        if (error.noKeyChain) {\n          throw new ValidateError(error.message, { final: true });\n        }\n        let keyChainStr = getKeyStr([...keyChain, { type: 'prop', key }]);\n        keyChainStr = `\"${keyChainStr}\": `;\n        throw new ValidateError(`${keyChainStr}${error.message}`, { final: true });\n      }\n    }\n    return result;\n  }\n\n  validate(obj, useKeyChain, keyChain) {\n    if (!this.requiredRestrict && isNotRequired(obj)) {\n      return this.getReturnValue(obj);\n    }\n\n    try {\n      this.checkType(obj);\n      this.checkRequired(obj);\n      this.checkRestricts(obj);\n\n      return this.getReturnValue(\n        this.validateRecurse(obj, useKeyChain === 'USE_KEY_CHAIN' ? keyChain : undefined)\n      );\n    } catch (error) {\n      if (error.custom === true) {\n        throw error;\n      }\n      const errorForAll = this.getErrorForAll(error.message);\n      if (errorForAll) {\n        throw errorForAll;\n      }\n      throw error;\n    }\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isArray,\n  isUndefined,\n  isNull\n} from '../utils/is';\n\nexport default class RestrictArrayType extends RestrictBase {\n  validate(val) {\n    if (isArray(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof array');\n  }\n}\n","import {\n  isNotRequired,\n  getKeyStr,\n} from '../utils/is';\nimport ValidateError from '../utils/validate-error';\nimport { TYPE } from '../utils/constants';\nimport RestrictArrayType from '../restricts/array-type';\nimport RestrictLengthMin from '../restricts/length-min';\nimport RestrictLengthMax from '../restricts/length-max';\nimport TypeBase from './base';\n\nexport default class TypeArray extends TypeBase {\n  type = TYPE.array;\n  itemSchema = null;\n\n  constructor(itemSchema) {\n    super();\n    this.typeRestrict = new RestrictArrayType();\n    this.currentRestrict = this.typeRestrict;\n    if (itemSchema instanceof TypeBase) {\n      this.itemSchema = itemSchema;\n    }\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictLengthMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictLengthMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {Array} array - array to validate\n   * @param {Array} [keyChain=[]] - props key chain\n   * @returns {Array} - result of validate\n   */\n  validateRecurse(array, keyChain) {\n    keyChain = keyChain || [];\n    const { itemSchema } = this;\n\n    if (itemSchema) {\n      const result = [];\n      for (let i = 0; i < array.length; i += 1) {\n        try {\n          if (itemSchema.type === TYPE.array || itemSchema.type === TYPE.object) {\n            result.push(\n              itemSchema.validate(array[i], 'USE_KEY_CHAIN', [...keyChain, { type: 'index', key: i }])\n            );\n          } else {\n            result.push(\n              itemSchema.validate(array[i])\n            );\n          }\n        } catch (error) {\n          if (error.final) {\n            throw error;\n          }\n          if (error.noKeyChain) {\n            throw new ValidateError(error.message, { final: true });\n          }\n          let keyChainStr = getKeyStr([...keyChain, { type: 'index', key: i }]);\n          keyChainStr = `\"${keyChainStr}\": `;\n          throw new ValidateError(`${keyChainStr}${error.message}`, { final: true });\n        }\n      }\n      return result;\n    }\n    return array;\n  }\n\n  validate(array, useKeyChain, keyChain) {\n    if (!this.requiredRestrict && isNotRequired(array)) {\n      return this.getReturnValue(array);\n    }\n\n    try {\n      this.checkType(array);\n      this.checkRequired(array);\n      this.checkRestricts(array);\n\n      return this.getReturnValue(\n        this.validateRecurse(array, useKeyChain === 'USE_KEY_CHAIN' ? keyChain : undefined)\n      );\n    } catch (error) {\n      if (error.custom === true) {\n        throw error;\n      }\n      const errorForAll = this.getErrorForAll(error.message);\n      if (errorForAll) {\n        throw errorForAll;\n      }\n      throw error;\n    }\n  }\n}\n","import {\n  TypeNumber,\n  TypeString,\n  TypeBoolean,\n  TypeAny,\n  TypeObject,\n  TypeArray\n} from './type';\n\nexport function number() {\n  return new TypeNumber();\n}\n\nexport function string() {\n  return new TypeString();\n}\n\nexport function boolean() {\n  return new TypeBoolean();\n}\n\nexport function any() {\n  return new TypeAny();\n}\n\nexport function object(config) {\n  return new TypeObject(config);\n}\n\nexport function array(itemSchema) {\n  return new TypeArray(itemSchema);\n}\n\nexport default {\n  number,\n  string,\n  boolean,\n  any,\n  object,\n  array\n};\n"],"names":["toString","Object","prototype","getType","val","str","call","substring","length","isUndefined","isNull","isNaN","isNotRequired","isEmpty","type","keys","isFalsy","isString","isNumber","isObject","isFunction","getKeyStr","keyChain","propReg","result","i","key","test","TYPE","number","string","object","array","any","ValidateError","message","options","noKeyChain","final","custom","Error","RestrictBase","errorConfig","ctx","originMessage","this","RestrictNumberType","isAllowNaN","isAllowInfinity","getError","Number","isFinite","isInfinity","RestrictRequired","RestrictEnum","enumValues","values","RangeError","indexOf","valueStr","JSON","stringify","RestrictNumberMax","max","closed","TypeError","RestrictNumberMin","min","RestrictNumberInt","Math","floor","isInt","strict","RestrictCustom","restrictFn","error","TypeBase","restricts","typeRestrict","requiredRestrict","currentRestrict","defaultConfig","enable","value","undefined","formatterConfig","formatter","errorForAllConfig","restrict","push","setErrorMessage","args","assign","calcDefaultValue","originalMessage","validate","getReturnValue","checkType","checkRequired","checkRestricts","errorForAll","getErrorForAll","NUMBER_REG","TypeNumber","isAllowString","_this","RestrictNumberRequired","enableAllowNaN","enableAllowInfinity","RestrictStringType","RestrictLengthMax","RestrictLengthMin","RestrictStringPattern","pattern","RegExp","TypeString","getReturnValueWithStrict","RestrictBooleanType","isBoolean","TypeBoolean","RestrictAnyType","isEmptyObject","isEmptyArray","TypeAny","RestrictAnyRequired","RestrictObjectType","TypeObject","config","isStripUnknown","isAllowUnknown","pureConfig","create","forEach","includes","obj","schema","hasKey","keyChainStr","useKeyChain","validateRecurse","RestrictArrayType","Array","isArray","TypeArray","itemSchema","boolean"],"mappings":"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"}