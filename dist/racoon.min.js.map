{"version":3,"file":"racoon.min.js","sources":["../lib/utils/is.js","../lib/utils/constants.js","../lib/utils/validate-error.js","../lib/restricts/base.js","../lib/restricts/number-type.js","../lib/restricts/number-required.js","../lib/restricts/enum.js","../lib/restricts/number-max.js","../lib/restricts/number-min.js","../lib/restricts/number-int.js","../lib/restricts/required.js","../lib/restricts/custom.js","../lib/type/base.js","../lib/type/number.js","../lib/restricts/string-type.js","../lib/restricts/length-max.js","../lib/restricts/length-min.js","../lib/restricts/string-pattern.js","../lib/type/string.js","../lib/restricts/boolean-type.js","../lib/type/boolean.js","../lib/restricts/any-type.js","../lib/restricts/any-required.js","../lib/type/any.js","../lib/restricts/object-type.js","../lib/type/object.js","../lib/restricts/array-type.js","../lib/type/arrary.js","../lib/index.js"],"sourcesContent":["export const toString = Object.prototype.toString;\n\nexport function getType(val) {\n  const str = toString.call(val);\n  return str.substring(8, str.length - 1);\n}\n\nexport function isUndefined(val) {\n  return getType(val) === 'Undefined';\n}\n\nexport function isNull(val) {\n  return val === null;\n}\n\nexport function isNaN(val) {\n  return val !== val;\n}\n\nexport function isNotRequired(val) {\n  return isUndefined(val) || isNull(val);\n}\n\nexport function isFalsy(val) {\n  return !val;\n}\n\nexport function isEmpty(val) {\n  const type = getType(val);\n  if (type === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n  if (type === 'Array' || type === 'Arguments') {\n    return val.length === 0;\n  }\n  return isFalsy(val);\n}\n\nexport function isEmptyObject(val) {\n  if (getType(val) === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n  return false;\n}\n\nexport function isEmptyArray(val) {\n  if (getType(val) === 'Array') {\n    return val.length === 0;\n  }\n  return false;\n}\n\nexport function isString(val) {\n  return typeof val === 'string';\n}\n\nexport function isNumber(val) {\n  return typeof val === 'number';\n}\n\nexport function isInt(val) {\n  if (isNumber(val) === false) {\n    return false;\n  }\n  return Math.floor(val) === val;\n}\n\nexport function isInfinity(val) {\n  return isNumber(val) && isNaN(val) === false && Number.isFinite(val) === false;\n}\n\nexport function isBoolean(val) {\n  return typeof val === 'boolean';\n}\n\nexport function isRegExp(val) {\n  return val instanceof RegExp;\n}\n\nexport function isObject(val) {\n  return getType(val) === 'Object';\n}\n\nexport function isArray(val) {\n  return Array.isArray(val);\n}\n\nexport function isFunction(val) {\n  return getType(val) === 'Function';\n}\n\nexport function getKeyStr(keyChain) {\n  const propReg = /^[_$a-z][_$a-z\\d]*$/i;\n  let result = '';\n  for (let i = 0; i < keyChain.length; i += 1) {\n    const { type, key } = keyChain[i];\n    if (type === 'prop' && propReg.test(key)) {\n      if (result) {\n        result += `.${key}`;\n      } else {\n        result += key;\n      }\n    } else if (type === 'prop') {\n      result += `['${key}']`;\n    } else if (type === 'index') {\n      result += `[${key}]`;\n    }\n  }\n  return result;\n}\n","export const TYPE = {\n  number: 'number',\n  string: 'string',\n  boolean: 'boolean',\n  object: 'object',\n  array: 'array',\n  any: 'any'\n};\n","export default class ValidateError extends Error {\n  get [Symbol.toStringTag]() {\n    return 'ValidateError';\n  }\n\n  toString() {\n    return `Validate${super.toString()}`;\n  }\n}\n","import { isFunction } from '../utils/is';\nimport ValidateError from '../utils/validate-error';\n\nexport default class RestrictBase {\n  errorConfig = {\n    message: '',\n    ctx: null\n  }\n\n  setErrorMessage(message, ctx) {\n    this.errorConfig = {\n      message,\n      ctx,\n    };\n  }\n\n  getError(originMessage) {\n    const { message, ctx } = this.errorConfig;\n    if (isFunction(message)) {\n      return new ValidateError(\n        message.call(ctx, originMessage)\n      );\n    }\n    return new ValidateError(message || originMessage);\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isNaN,\n  isNumber,\n  isUndefined,\n  isNull,\n  isInfinity\n} from '../utils/is';\n\nexport default class RestrictNumberType extends RestrictBase {\n  isAllowNaN = false;\n  isAllowInfinity = false;\n\n  enableAllowNaN() {\n    this.isAllowNaN = true;\n  }\n\n  enableAllowInfinity() {\n    this.isAllowInfinity = true;\n  }\n\n  validate(val) {\n    const { isAllowNaN, isAllowInfinity } = this;\n    if (isNaN(val) && isAllowNaN === false) {\n      throw this.getError('value is not allowed to be NaN');\n    }\n    if (isInfinity(val) && isAllowInfinity === false) {\n      throw this.getError('value is not allowed to be Infinity');\n    }\n    if (isNumber(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof number');\n  }\n}\n","import RestrictBase from './base';\nimport { isNaN, isNotRequired } from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  validate(val) {\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n    if (isNaN(val)) {\n      throw this.getError('value is required and should not be NaN');\n    }\n    return true;\n  }\n}\n","import RestrictBase from './base';\n\nexport default class RestrictEnum extends RestrictBase {\n  enumValues = null;\n\n  constructor(...values) {\n    super();\n    if (values.length === 0) {\n      throw new RangeError('enum arguments can not be empty');\n    }\n    this.enumValues = values;\n  }\n\n  get valueStr() {\n    return JSON.stringify(this.enumValues);\n  }\n\n  validate(val) {\n    if (this.enumValues.indexOf(val) > -1) {\n      return true;\n    }\n    throw this.getError(`value should be one of ${this.valueStr}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictNumberMax extends RestrictBase {\n  constructor(max, closed = true) {\n    super();\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be typeof number');\n    }\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed === false) {\n      if (val < this.max) {\n        return true;\n      }\n      throw this.getError(`value should less than ${this.max}`);\n    }\n\n    if (val <= this.max) {\n      return true;\n    }\n    throw this.getError(`value should less than or equal ${this.max}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictNumberMin extends RestrictBase {\n  constructor(min, closed = true) {\n    super();\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed === false) {\n      if (val > this.min) {\n        return true;\n      }\n      throw this.getError(`value should greater than ${this.min}`);\n    }\n\n    if (val >= this.min) {\n      return true;\n    }\n    throw this.getError(`value should greater than or equal ${this.min}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isInt } from '../utils/is';\n\nexport default class RestrictNumberInt extends RestrictBase {\n  validate(val) {\n    if (isInt(val)) {\n      return true;\n    }\n    throw this.getError('value should be an int');\n  }\n}\n","import RestrictBase from './base';\nimport { isEmpty, isNotRequired } from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  validate(val) {\n    const { strict } = this;\n    if (strict === true) {\n      if (isEmpty(val)) {\n        throw this.getError('value is required and should not be empty');\n      }\n      return true;\n    }\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n    return true;\n  }\n}\n","import { isFunction } from '../utils/is';\nimport RestrictBase from './base';\n\nexport default class RestrictCustom extends RestrictBase {\n  constructor(restrictFn, ctx) {\n    super();\n    if (isFunction(restrictFn) === false) {\n      throw new TypeError('`custom` must receive a Function parameter');\n    }\n    this.restrictFn = restrictFn;\n    this.ctx = ctx;\n  }\n\n  validate(val) {\n    try {\n      this.restrictFn.call(this.ctx, val);\n    } catch (error) {\n      throw this.getError(error.message);\n    }\n    return true;\n  }\n}\n","import {\n  isEmpty,\n  isNotRequired,\n  isNaN\n} from '../utils/is';\nimport RestrictRequired from '../restricts/required';\nimport RestrictCustom from '../restricts/custom';\n\nexport default class TypeBase {\n  restricts = [];\n  typeRestrict = null;\n  requiredRestrict = null;\n  currentRestrict = null;\n  defaultConfig = {\n    enable: false,\n    strict: false,\n    value: undefined\n  };\n  formatterConfig = {\n    ctx: undefined,\n    formatter: val => val\n  };\n\n  required(strict = false) {\n    this.requiredRestrict = new RestrictRequired(strict);\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  custom(restrictFn, ctx) {\n    const restrict = new RestrictCustom(restrictFn, ctx);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  error(message, ctx) {\n    this.currentRestrict.setErrorMessage(message, ctx);\n    return this;\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, strict, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: strict === true,\n      value,\n      ctx\n    });\n    return this;\n  }\n\n  format(formatter, ctx) {\n    if (typeof formatter !== 'function') {\n      throw new TypeError('`format` argument should be a function');\n    }\n    this.formatterConfig = {\n      ctx,\n      formatter\n    };\n    return this;\n  }\n\n  calcDefaultValue(val) {\n    const { value, ctx } = this.defaultConfig;\n    if (typeof value === 'function') {\n      return value.call(ctx, val);\n    }\n    return value;\n  }\n\n  getReturnValueWithStrict(val) {\n    const { enable, strict } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    if (enable && (isNotRequired(val) || isNaN(val))) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    if (enable && isEmpty(val) && strict) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  getReturnValue(val) {\n    const { formatter, ctx } = this.formatterConfig;\n    if (this.defaultConfig.enable && (isNotRequired(val) || isNaN(val))) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  checkType(val) {\n    return this.typeRestrict.validate(val);\n  }\n\n  checkRequired(val) {\n    if (!this.requiredRestrict) {\n      return true;\n    }\n\n    return this.requiredRestrict.validate(val);\n  }\n\n  checkRestricts(val) {\n    for (let i = 0; i < this.restricts.length; i += 1) {\n      this.restricts[i].validate(val);\n    }\n    return true;\n  }\n\n  validate(val) {\n    if (!this.requiredRestrict && isNotRequired(val)) {\n      return this.getReturnValue(val);\n    }\n    this.checkType(val);\n    this.checkRequired(val);\n    this.checkRestricts(val);\n\n    return this.getReturnValue(val);\n  }\n\n  validateSilent(val) {\n    try {\n      return {\n        value: this.validate(val)\n      };\n    } catch (error) {\n      return {\n        error,\n        value: val\n      };\n    }\n  }\n}\n","import {\n  isNaN,\n  isNotRequired\n} from '../utils/is';\nimport { TYPE } from '../utils/constants';\nimport RestrictNumberType from '../restricts/number-type';\nimport RestrictNumberRequired from '../restricts/number-required';\nimport RestrictEnum from '../restricts/enum';\nimport RestrictNumberMax from '../restricts/number-max';\nimport RestrictNumberMin from '../restricts/number-min';\nimport RestrictNumberInt from '../restricts/number-int';\nimport TypeBase from './base';\n\nexport default class TypeNumber extends TypeBase {\n  type = TYPE.number;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictNumberType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    const { enable } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    if (\n      enable\n      && (isNotRequired(val) || isNaN(val))\n    ) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: false,\n      value,\n      ctx\n    });\n    return this;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  required() {\n    this.requiredRestrict = new RestrictNumberRequired();\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  allowNaN() {\n    this.typeRestrict.enableAllowNaN();\n    return this;\n  }\n\n  allowInfinity() {\n    this.typeRestrict.enableAllowInfinity();\n    return this;\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictNumberMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictNumberMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  int() {\n    const restrict = new RestrictNumberInt();\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isString,\n  isNotRequired\n} from '../utils/is';\n\nexport default class RestrictStringType extends RestrictBase {\n  validate(val) {\n    if (isString(val) || isNotRequired(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof string');\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictLengthMax extends RestrictBase {\n  constructor(max, closed = true) {\n    super();\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be typeof number');\n    }\n\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed) {\n      if (val.length <= this.max) {\n        return true;\n      }\n      throw this.getError(`value length should less than or equal ${this.max}`);\n    }\n    if (val.length < this.max) {\n      return true;\n    }\n    throw this.getError(`value length should less than ${this.max}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictLengthMin extends RestrictBase {\n  constructor(min, closed = true) {\n    super();\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed) {\n      if (val.length >= this.min) {\n        return true;\n      }\n      throw this.getError(`value length should greater than or equal ${this.min}`);\n    }\n    if (val.length > this.min) {\n      return true;\n    }\n    throw this.getError(`value length should greater than ${this.min}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isRegExp } from '../utils/is';\n\nexport default class RestrictStringPattern extends RestrictBase {\n  constructor(pattern) {\n    super();\n    if (isRegExp(pattern) === false) {\n      throw new TypeError('pattern should be a RegExp');\n    }\n    this.pattern = pattern;\n  }\n\n  validate(val) {\n    if (this.pattern.test(val)) {\n      return true;\n    }\n    throw this.getError(`value should match pattern ${this.pattern.toString()}`);\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictStringType from '../restricts/string-type';\nimport RestrictEnum from '../restricts/enum';\nimport RestrictLengthMax from '../restricts/length-max';\nimport RestrictLengthMin from '../restricts/length-min';\nimport RestrictStringPattern from '../restricts/string-pattern';\nimport TypeBase from './base';\n\nexport default class TypeString extends TypeBase {\n  type = TYPE.string;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictStringType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictLengthMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictLengthMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  pattern(pattern) {\n    const restrict = new RestrictStringPattern(pattern);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isBoolean,\n  isNotRequired\n} from '../utils/is';\n\nexport default class RestrictBooleanType extends RestrictBase {\n  validate(val) {\n    if (isBoolean(val) || isNotRequired(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof boolean');\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictBooleanType from '../restricts/boolean-type';\nimport RestrictEnum from '../restricts/enum';\nimport TypeBase from './base';\n\nexport default class TypeBoolean extends TypeBase {\n  type = TYPE;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictBooleanType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: false,\n      value,\n      ctx\n    });\n    return this;\n  }\n}\n","import RestrictBase from './base';\n\nexport default class RestrictAnyType extends RestrictBase {\n  validate(val) {\n    return true;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isNaN,\n  isNotRequired,\n  isEmptyObject,\n  isEmptyArray\n} from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  validate(val) {\n    const { strict } = this;\n    if (strict === true) {\n      if (\n        isNotRequired(val)\n        || val === ''\n        || isNaN(val)\n        || isEmptyObject(val)\n        || isEmptyArray(val)\n      ) {\n        throw this.getError('value is required and should not be empty');\n      }\n      return true;\n    }\n    if (isNotRequired(val) || isNaN(val)) {\n      throw this.getError('value is required and should not be undefined/null/NaN');\n    }\n    return true;\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictAnyType from '../restricts/any-type';\nimport RestrictAnyRequired from '../restricts/any-required';\nimport RestrictEnum from '../restricts/enum';\nimport TypeBase from './base';\n\nexport default class TypeAny extends TypeBase {\n  type = TYPE.any;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictAnyType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  required(strict = false) {\n    this.requiredRestrict = new RestrictAnyRequired(strict);\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isObject,\n  isUndefined,\n  isNull\n} from '../utils/is';\n\nexport default class RestrictObjectType extends RestrictBase {\n  validate(val) {\n    if (isObject(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof object');\n  }\n}\n","import {\n  isObject,\n  isNotRequired,\n  getKeyStr,\n} from '../utils/is';\nimport { TYPE } from '../utils/constants';\nimport RestrictObjectType from '../restricts/object-type';\nimport ValidateError from '../utils/validate-error';\nimport TypeBase from './base';\n\nexport default class TypeObject extends TypeBase {\n  type = TYPE.object;\n  config = null;\n  isStripUnknown = false;\n  isAllowUnknown = false;\n\n  constructor(config) {\n    super();\n    this.typeRestrict = new RestrictObjectType();\n    this.currentRestrict = this.typeRestrict;\n    if (isObject(config)) {\n      const pureConfig = Object.create(null);\n      Object.keys(config).forEach(key => {\n        if (config[key] instanceof TypeBase) {\n          pureConfig[key] = config[key];\n        }\n      });\n      this.config = pureConfig;\n    }\n  }\n\n  get keys() {\n    return Object.keys(this.config);\n  }\n\n  hasKey(key) {\n    return this.keys.includes(key);\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  stripUnknown() {\n    this.isStripUnknown = true;\n    return this;\n  }\n\n  allowUnknown() {\n    this.isAllowUnknown = true;\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {Object} obj - object to validate\n   * @param {Array} [keyChain=[]] - object props chain\n   * @returns {Object} - result of validate\n   */\n  validateRecurse(obj, keyChain) {\n    keyChain = keyChain || [];\n\n    if (this.config === null) {\n      return obj;\n    }\n\n    const result = {};\n    let keys;\n    if (this.isStripUnknown === true) {\n      keys = this.keys;\n    } else {\n      keys = Object.keys(obj);\n    }\n    for (let i = 0; i < keys.length; i += 1) {\n      const key = keys[i];\n      const schema = this.config[key];\n      if (this.hasKey(key) === false) {\n        if (this.isStripUnknown === true) {\n          continue;\n        }\n        if (this.isAllowUnknown === true) {\n          result[key] = obj[key];\n          continue;\n        }\n        throw new ValidateError(`the key \\`${key}\\` is not allowed`);\n      }\n\n      try {\n        if (schema.type === TYPE.object || schema.type === TYPE.array) {\n          result[key] = schema.validateRecurse(\n            obj[key],\n            [\n              ...keyChain,\n              {\n                key,\n                type: 'prop'\n              }\n            ]\n          );\n        } else {\n          result[key] = schema.validate(obj[key]);\n        }\n      } catch (error) {\n        if (error instanceof ValidateError) {\n          let keyChainStr = getKeyStr([...keyChain, { type: 'prop', key }]);\n          if (keyChainStr) {\n            keyChainStr = `\"${keyChainStr}\": `;\n          }\n          throw new Error(`${keyChainStr}${error.message}`);\n        } else {\n          throw error;\n        }\n      }\n    }\n    return result;\n  }\n\n  validate(obj) {\n    if (!this.requiredRestrict && isNotRequired(obj)) {\n      return this.getReturnValue(obj);\n    }\n    this.checkRequired(obj);\n    this.checkType(obj);\n    this.checkRestricts(obj);\n\n    return this.getReturnValue(\n      this.validateRecurse(obj)\n    );\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isArray,\n  isUndefined,\n  isNull\n} from '../utils/is';\n\nexport default class RestrictArrayType extends RestrictBase {\n  validate(val) {\n    if (isArray(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof array');\n  }\n}\n","import {\n  isNotRequired,\n  getKeyStr,\n} from '../utils/is';\nimport ValidateError from '../utils/validate-error';\nimport { TYPE } from '../utils/constants';\nimport RestrictArrayType from '../restricts/array-type';\nimport RestrictLengthMin from '../restricts/length-min';\nimport RestrictLengthMax from '../restricts/length-max';\nimport TypeBase from './base';\n\nexport default class TypeArray extends TypeBase {\n  type = TYPE.array;\n  itemSchema = null;\n\n  constructor(itemSchema) {\n    super();\n    this.typeRestrict = new RestrictArrayType();\n    this.currentRestrict = this.typeRestrict;\n    if (itemSchema instanceof TypeBase) {\n      this.itemSchema = itemSchema;\n    }\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictLengthMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictLengthMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {Array} array - array to validate\n   * @param {Array} [keyChain=[]] - props key chain\n   * @returns {Array} - result of validate\n   */\n  validateRecurse(array, keyChain) {\n    keyChain = keyChain || [];\n    const { itemSchema } = this;\n\n    if (itemSchema) {\n      const result = [];\n      for (let i = 0; i < array.length; i += 1) {\n        try {\n          if (itemSchema.type === TYPE.array || itemSchema.type === TYPE.object) {\n            result.push(\n              itemSchema.validateRecurse(array[i], [...keyChain, { type: 'index', key: i }])\n            );\n          } else {\n            result.push(\n              itemSchema.validate(array[i])\n            );\n          }\n        } catch (error) {\n          if (error instanceof ValidateError) {\n            let keyChainStr = getKeyStr([...keyChain, { type: 'index', key: i }]);\n            if (keyChainStr) {\n              keyChainStr = `\"${keyChainStr}\": `;\n            }\n            throw new Error(`${keyChainStr}${error.message}`);\n          } else {\n            throw error;\n          }\n        }\n      }\n      return result;\n    }\n    return array;\n  }\n\n  validate(array) {\n    if (!this.requiredRestrict && isNotRequired(array)) {\n      return this.getReturnValue(array);\n    }\n    this.checkRequired(array);\n    this.checkType(array);\n    this.checkRestricts(array);\n\n    return this.getReturnValue(\n      this.validateRecurse(array)\n    );\n  }\n}\n","import {\n  TypeNumber,\n  TypeString,\n  TypeBoolean,\n  TypeAny,\n  TypeObject,\n  TypeArray\n} from './type';\n\nexport function number() {\n  return new TypeNumber();\n}\n\nexport function string() {\n  return new TypeString();\n}\n\nexport function boolean() {\n  return new TypeBoolean();\n}\n\nexport function any() {\n  return new TypeAny();\n}\n\nexport function object(config) {\n  return new TypeObject(config);\n}\n\nexport function array(itemSchema) {\n  return new TypeArray(itemSchema);\n}\n\nexport default {\n  number,\n  string,\n  boolean,\n  any,\n  object,\n  array\n};\n"],"names":["toString","Object","prototype","getType","val","str","call","substring","length","isUndefined","isNull","isNaN","isNotRequired","isEmpty","type","keys","isFalsy","isNumber","isObject","isFunction","getKeyStr","keyChain","propReg","result","i","key","test","TYPE","number","string","object","array","any","ValidateError","Symbol","toStringTag","Error","RestrictBase","errorConfig","message","ctx","originMessage","this","RestrictNumberType","isAllowNaN","isAllowInfinity","getError","Number","isFinite","isInfinity","RestrictRequired","RestrictEnum","enumValues","values","RangeError","indexOf","valueStr","JSON","stringify","RestrictNumberMax","max","closed","TypeError","RestrictNumberMin","min","RestrictNumberInt","Math","floor","isInt","strict","RestrictCustom","restrictFn","error","TypeBase","restricts","typeRestrict","requiredRestrict","currentRestrict","defaultConfig","enable","value","undefined","formatterConfig","formatter","restrict","push","setErrorMessage","args","assign","calcDefaultValue","validate","checkType","checkRequired","checkRestricts","getReturnValue","TypeNumber","_this","RestrictNumberRequired","enableAllowNaN","enableAllowInfinity","RestrictStringType","isString","RestrictLengthMax","RestrictLengthMin","RestrictStringPattern","pattern","RegExp","TypeString","getReturnValueWithStrict","RestrictBooleanType","isBoolean","TypeBoolean","RestrictAnyType","isEmptyObject","isEmptyArray","TypeAny","RestrictAnyRequired","RestrictObjectType","TypeObject","config","isStripUnknown","isAllowUnknown","pureConfig","create","forEach","includes","obj","schema","hasKey","validateRecurse","keyChainStr","RestrictArrayType","Array","isArray","TypeArray","itemSchema","boolean"],"mappings":"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"}