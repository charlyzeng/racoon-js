{"version":3,"file":"racoon.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../lib/util/constants.js","../node_modules/@babel/runtime/helpers/esm/get.js","../node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../lib/util/validate-error.js","../lib/util/is.js","../lib/restrict/base.js","../lib/restrict/any-schema.js","../lib/restrict/any-required.js","../lib/restrict/enum.js","../lib/restrict/required.js","../lib/restrict/custom.js","../lib/schema/base.js","../lib/schema/any.js","../lib/restrict/number-schema.js","../lib/restrict/number-required.js","../lib/restrict/number-max.js","../lib/restrict/number-min.js","../lib/restrict/number-int.js","../lib/restrict/number-even.js","../lib/restrict/number-odd.js","../lib/schema/number.js","../lib/restrict/string-schema.js","../lib/restrict/length-max.js","../lib/restrict/length-min.js","../lib/restrict/string-pattern.js","../lib/schema/string.js","../lib/restrict/boolean-schema.js","../lib/schema/boolean.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../lib/util/get-key-str.js","../lib/restrict/object-schema.js","../lib/schema/object.js","../lib/restrict/array-schema.js","../lib/schema/arrary.js","../lib/schema/mixed.js","../lib/index.js"],"sourcesContent":["export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export const TYPE = {\n  number: 'number',\n  string: 'string',\n  boolean: 'boolean',\n  object: 'object',\n  array: 'array',\n  any: 'any',\n};\n\nexport const useKeyChainSymbol = Symbol('#useKeyChainSymbol');\n","import superPropBase from \"@babel/runtime/helpers/esm/superPropBase\";\nexport default function _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeFunction from \"@babel/runtime/helpers/esm/isNativeFunction\";\nimport construct from \"@babel/runtime/helpers/esm/construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","export default class ValidateError extends Error {\n  custom = false;\n  final = false;\n\n  constructor(message, options = {}) {\n    super(message);\n    const {\n      custom = false,\n      final = false,\n    } = options;\n\n    this.custom = custom;\n    this.final = final;\n  }\n\n  toString() {\n    return `Validate${super.toString()}`;\n  }\n}\n","import ValidateError from './validate-error';\n\nconst { toString } = Object.prototype;\n\nexport function getType(val) {\n  const str = toString.call(val);\n  return str.substring(8, str.length - 1);\n}\n\nexport function isUndefined(val) {\n  return val === undefined;\n}\n\nexport function isNull(val) {\n  return val === null;\n}\n\nexport function isNaN(val) {\n  return val !== val;\n}\n\nexport function isString(val) {\n  return typeof val === 'string';\n}\n\nexport function isNumber(val) {\n  return typeof val === 'number';\n}\n\nexport function isInt(val) {\n  return isNumber(val) && val % 1 === 0;\n}\n\nexport function isInfinity(val) {\n  return (\n    val === Number.POSITIVE_INFINITY\n    || val === Number.NEGATIVE_INFINITY\n  );\n}\n\nexport function isBoolean(val) {\n  return typeof val === 'boolean';\n}\n\nexport function isRegExp(val) {\n  return val instanceof RegExp;\n}\n\nexport function isObject(val) {\n  return getType(val) === 'Object';\n}\n\nexport function isArray(val) {\n  return getType(val) === 'Array';\n}\n\nexport function isNotRequired(val) {\n  return isUndefined(val) || isNull(val);\n}\n\nexport function isEmpty(val) {\n  const type = getType(val);\n\n  if (type === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n\n  if (type === 'Array') {\n    return val.length === 0;\n  }\n\n  return (\n    isNotRequired(val)\n    || isNaN(val)\n    || val === ''\n  );\n}\n\n/**\n * Check if the value is Function. AsyncFunction or GeneratorFunction will\n * return false.\n *\n * @param {*} val The value to check.\n */\nexport function isFunction(val) {\n  return getType(val) === 'Function';\n}\n\n/**\n * Detect string whether can be parsed to number by `Number('xxx')`.\n *\n * Special case:\n * When the detected string is empty or only includes white spaces, the string\n * can be parsed to zero although, but it won't be regarded as a parsable\n * string still.\n *\n * @param {string} val The detected string.\n * @returns {boolean}\n */\nexport function isStringNumber(val) {\n  if (/^\\s*$/.test(val)) {\n    return false;\n  }\n  return !isNaN(Number(val));\n}\n\n/**\n * Check the error is a customed ValidateError.\n *\n * @param {Error} error The error object to check.\n */\nexport function isCustomError(error) {\n  return error instanceof ValidateError && error.custom;\n}\n\n/**\n * Check the error is a final ValidateError.\n *\n * @param {Error} error The error object to check.\n */\nexport function isFinalError(error) {\n  return error instanceof ValidateError && error.final;\n}\n","/**\n * The base class of all restrict.\n */\n\nimport { isFunction, isString } from '../util/is';\nimport ValidateError from '../util/validate-error';\n\nexport default class RestrictBase {\n  // To custom the error message when restrict validate fail. The message field\n  // can be either a string or a function, when it's a function, the ctx field\n  // can specify execute context of message function.\n  errorConfig = {\n    ctx: null,\n    message: '',\n  }\n\n  /**\n   * set errorConfig\n   *\n   * @param {String|Function} message The message of error.\n   * @param {*} [ctx] The execute context when message is a function.\n   */\n  setErrorMessage(message, ctx) {\n    this.errorConfig = {\n      ctx,\n      message,\n    };\n  }\n\n  /**\n   * Get the final error message when validate fail.\n   *\n   * @param {String} originMessage The origin message that throwed by racoon.\n   * @returns {ValidateError}\n   */\n  getError(originMessage) {\n    const { message, ctx } = this.errorConfig;\n\n    if (isFunction(message)) {\n      return new ValidateError(\n        message.call(ctx, originMessage),\n        { custom: true },\n      );\n    }\n\n    if (message && isString(message)) {\n      return new ValidateError(\n        message,\n        { custom: true },\n      );\n    }\n\n    return new ValidateError(originMessage);\n  }\n}\n","/**\n * Restrict value to be any type, which means that it will not\n * restrict the type of value. So, the validate method return\n * true always.\n */\n\nimport RestrictBase from './base';\n\nexport default class RestrictAnySchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"any-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate() {\n    return true;\n  }\n}\n","/**\n * This is for any schema, to estrict value to be non-empty. By default,\n * non-empty means the detected value cann't be undefined, null. When in\n * strict mode, the detected value cann't be undefined, null, empty-string,\n * empty-object or empty-array.\n */\n\nimport RestrictBase from './base';\nimport {\n  isNaN,\n  isEmpty,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictAnyRequired extends RestrictBase {\n  strict = false;\n\n  /**\n   * @param {Boolean} strict Whether to enable strict mode. By default, strict mode\n   * is disabled. If strict param is passed to exactly true, strict mode will be\n   * enabled.\n   */\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  /**\n   * Check the detected value whether meets this \"any-required\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    const { strict } = this;\n\n    // In non-strict mode, if the detected value is undefined, null or NaN, the\n    // validation will be fail.\n    if (!strict && (isNotRequired(val) || isNaN(val))) {\n      throw this.getError('value is required and should not be undefined/null/NaN');\n    }\n\n    if (strict === true && isEmpty(val)) {\n      throw this.getError('value is required and should not be empty');\n    }\n  }\n}\n","/**\n * Restrict value to be some enum values.\n */\n\nimport RestrictBase from './base';\n\nexport default class RestrictEnum extends RestrictBase {\n  enumValues = null;\n\n  /**\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  constructor(...values) {\n    super();\n\n    if (values.length === 0) {\n      throw new RangeError('enum arguments should not be empty');\n    }\n\n    this.enumValues = values;\n  }\n\n  /**\n   * Check the detected value whether meets this \"enum\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.enumValues.indexOf(val) === -1) {\n      throw this.getError(`value should be one of ${JSON.stringify(this.enumValues)}`);\n    }\n  }\n}\n","/**\n * Restrict the detected value to be non-empty. Non-empty means undefined,\n * null. When in strict mode, non-empty means undefined, null, empty-string,\n * empty-object, empty-array.\n */\n\nimport RestrictBase from './base';\nimport { isEmpty, isNotRequired } from '../util/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  /**\n   * @param {Boolean} [strict] Whether enable strict mode. By default, the mode\n   * is non-strict. If you pass strict exactly true, it will enable strict mode.\n   */\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  /**\n   * Check the detected value whether meets this \"required\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    const { strict } = this;\n\n    if (strict && isEmpty(val)) {\n      throw this.getError('value is required and should not be empty');\n    }\n\n    if (!strict && isNotRequired(val))  {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n  }\n}\n","/**\n * Restrict value by a custom callback function.\n */\n\nimport { isFunction, isString } from '../util/is';\nimport RestrictBase from './base';\n\nexport default class RestrictCustom extends RestrictBase {\n  ctx = null;\n  restrictFn = null;\n\n  /**\n   * If restrictFn throws an error or returns a string, the validation\n   * will be fail. The message of error or the returned string respect\n   * the error message of validation.\n   *\n   * @param {Function} restrictFn The custom restrict callback function.\n   * @param {*}        [ctx]      The exec context of restrictFn.\n   */\n  constructor(restrictFn, ctx) {\n    super();\n\n    if (isFunction(restrictFn) === false) {\n      throw new TypeError('`restrictFn` should be a type of function');\n    }\n\n    this.restrictFn = restrictFn;\n    this.ctx = ctx;\n  }\n\n  /**\n   * Check the detected value whether meets this \"custom\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    try {\n      const result = this.restrictFn.call(this.ctx, val);\n\n      // If restrictFn return a non-empty string, validation will be fail.\n      if (isString(result) && result) {\n        throw this.getError(result);\n      }\n    } catch (error) {\n      // If restrictFn throws an error, validation will be fail too. And\n      // then should throw a wrapped error.\n      throw this.getError(error.message);\n    }\n\n    return true;\n  }\n}\n","/**\n * Base class for all schema classes.\n */\n\nimport {\n  isEmpty,\n  isNotRequired,\n  isNaN,\n  isString,\n  isFunction,\n  isFinalError,\n  isCustomError,\n} from '../util/is';\nimport ValidateError from '../util/validate-error';\nimport RestrictRequired from '../restrict/required';\nimport RestrictCustom from '../restrict/custom';\n\nexport default class SchemaBase {\n  restricts = [];\n  typeRestrict = null;\n  requiredRestrict = null;\n\n  // Save the last restrict that added to schema. This is for add custom error\n  // message by call error method.\n  lastRestrict = null;\n\n  // The config of default return value when detected is empty.\n  defaultConfig = {\n    enable: false,\n    strict: false,\n    ctx: null,\n    value: undefined,\n  };\n\n  // The config of return value's formatter. By default, this will not do any\n  // formatting. This can be setted by call `format` method.\n  formatterConfig = {\n    ctx: undefined,\n    formatter: val => val,\n  };\n\n  // The custom error message config for all restricts. This can be setted by\n  // call 'errorForAll` method.\n  errorForAllConfig = {\n    enable: false,\n    ctx: undefined,\n    message: '',\n  };\n\n  /**\n   * Validate value.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    // When it's not required, and the detected value is undefined or null, then it's no need\n    // to validate any more, just return default value or default value after formated.\n    if (!this.requiredRestrict && isNotRequired(val)) {\n      return this.getReturnValue(val);\n    }\n\n    try {\n      this.checkType(val);\n      this.checkRequired(val);\n      this.checkRestricts(val);\n\n      return this.getReturnValue(val);\n    } catch (error) {\n      if (isCustomError(error)) {\n        throw error;\n      }\n\n      const errorForAll = this.getErrorForAll(error.message);\n\n      if (errorForAll) {\n        throw errorForAll;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Validate value by silent. The deference from validate method is that validate method will\n   * throw an error when validate fail, but validateSilent will not.\n   *\n   * @param {*} val The detected value.\n   */\n  validateSilent(val) {\n    try {\n      return {\n        value: this.validate(val),\n      };\n    } catch (error) {\n      return {\n        error,\n        value: val,\n      };\n    }\n  }\n\n  /**\n   * Add a \"required\" restrict to schema.\n   *\n   * @param {Boolean} [strict] Whether enable strict mode. By default, the mode\n   * is non-strict. If you pass strict exactly true, it will enable strict mode.\n   */\n  required(strict) {\n    this.requiredRestrict = new RestrictRequired(strict);\n    this.lastRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  /**\n   * Add a \"custom\" restrict to schema.\n   *\n   * @param {Function} restrictFn The custom restrict callback function.\n   * @param {*}        [ctx]      The exec context of restrictFn.\n   */\n  custom(restrictFn, ctx) {\n    const restrict = new RestrictCustom(restrictFn, ctx);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Set custom error message for the last restrict added to schema.\n   *\n   * @param {String|Function} message The custom error message.\n   * @param {*}               ctx     The excute context when message is a function.\n   */\n  error(message, ctx) {\n    this.ensureMessageType(message);\n    this.lastRestrict.setErrorMessage(message, ctx);\n    return this;\n  }\n\n  /**\n   * Set custom error message for all restrict. The message setted by `error` method\n   * is priority to that setted by `errorForAll`.\n   *\n   * @param {String|Function} message The custom error message.\n   * @param {*}               ctx     The excute context when message is a function.\n   */\n  errorForAll(message, ctx) {\n    this.ensureMessageType(message);\n    this.errorForAllConfig = {\n      enable: true,\n      message,\n      ctx,\n    };\n\n    return this;\n  }\n\n  /**\n   * Set the default return value of validate when the detected value is empty.\n   *\n   * @param {*}       args[0] The default return value.\n   * @param {boolean} args[1] Whether to enable strict mode.\n   * @param {*}       args[2] The execute context of value when value is a function.\n   */\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('default arguments should not be empty');\n    }\n\n    const [value, strict, ctx] = args;\n    this.defaultConfig = {\n      ctx,\n      value,\n      enable: true,\n      strict: strict === true,\n    };\n\n    return this;\n  }\n\n  /**\n   * Format the return value of validate method.\n   *\n   * @param {Function} formatter The function that format the return value.\n   * @param {*}        [ctx]     The execute context of formatter.\n   */\n  format(formatter, ctx) {\n    if (typeof formatter !== 'function') {\n      throw new TypeError('`formatter` should be a type of function');\n    }\n\n    this.formatterConfig = {\n      ctx,\n      formatter,\n    };\n\n    return this;\n  }\n\n  /**\n   * Get the last return value of validate.\n   *\n   * @param {*} val The origin detected value.\n   */\n  getReturnValue(val) {\n    const { enable, strict } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n\n    if (enable && strict && isEmpty(val)) {\n      return formatter.call(\n        ctx,\n        this.getDefaultReturnValue(val),\n      );\n    }\n\n    return this.getReturnValueWithoutStrict(val);\n  }\n\n  /**\n   * Get the default return value of validate.\n   *\n   * @param {*} val The origin detected value.\n   */\n  getDefaultReturnValue(val) {\n    const { value, ctx } = this.defaultConfig;\n\n    if (typeof value === 'function') {\n      return value.call(ctx, val);\n    }\n\n    return value;\n  }\n\n  /**\n   * Get the error message for all restricts.\n   *\n   * @param {string} originalMessage The origin error message throwed by racoon.\n   */\n  getErrorForAll(originalMessage) {\n    const {\n      ctx,\n      enable,\n      message,\n    } = this.errorForAllConfig;\n\n    if (enable !== true) {\n      return null;\n    }\n\n    if (isFunction(message)) {\n      return new ValidateError(message.call(ctx, originalMessage));\n    }\n\n    return new ValidateError(message);\n  }\n\n  /**\n   * Check if the detected value's type is right.\n   *\n   * @param {*} val The detected value.\n   */\n  checkType(val) {\n    return this.typeRestrict.validate(val);\n  }\n\n  /**\n   * Check if the detected value meet \"required\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  checkRequired(val) {\n    if (!this.requiredRestrict) {\n      return true;\n    }\n\n    return this.requiredRestrict.validate(val);\n  }\n\n  /**\n   * Check all restricts for the detected value.\n   *\n   * @param {*} val The detected value\n   */\n  checkRestricts(val) {\n    this.restricts.forEach((restrict) => {\n      restrict.validate(val);\n    });\n    return true;\n  }\n\n  /**\n   * Throw error without key chain when:\n   * 1. The error is the final error, it's no need to add key chain.\n   * 2. Or the error is custom error, it should not to add key chain.\n   *\n   * @param {Error} error The origin error object.\n   */\n  throwErrorWithoutKeyChainIfNeeded(error) {\n    if (isFinalError(error)) {\n      throw error;\n    }\n\n    if (isCustomError(error)) {\n      throw new ValidateError(error.message, { final: true });\n    }\n  }\n\n  /**\n   * @private\n   * Check if message is a valid type.\n   *\n   * @param {*} message The message param user passed.\n   */\n  ensureMessageType(message) {\n    if (!isString(message) && !isFunction(message)) {\n      throw new TypeError('`message` should be a type of string or function');\n    }\n  }\n\n  /**\n   * @private\n   * Get the last return value of validate. This is for non-strict mode scene.\n   *\n   * @param {*} val The origin return value.\n   */\n  getReturnValueWithoutStrict(val) {\n    const { enable } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    let value = val;\n\n    // If there is a default return value, then format the default value and\n    // return it.\n    if (enable && (isNotRequired(val) || isNaN(val))) {\n      value = this.getDefaultReturnValue(val);\n    }\n\n    // Otherwise, format the origin return value and return it.\n    return formatter.call(ctx, value);\n  }\n}\n","/**\n * Class for any schema.\n */\n\nimport { TYPE } from '../util/constants';\nimport RestrictAnySchema from '../restrict/any-schema';\nimport RestrictAnyRequired from '../restrict/any-required';\nimport RestrictEnum from '../restrict/enum';\nimport SchemaBase from './base';\n\nexport default class SchemaAny extends SchemaBase {\n  type = TYPE.any;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictAnySchema();\n    this.lastRestrict = this.typeRestrict;\n  }\n\n  /**\n   * Add a \"required\" restrict to any schema.\n   *\n   * @param {Boolean} [strict] Whether enable strict mode. By default, the mode\n   * is non-strict. If you pass strict exactly true, it will enable strict mode.\n   */\n  required(strict) {\n    this.requiredRestrict = new RestrictAnyRequired(strict);\n    this.lastRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  /**\n   * Add an \"enum\" restrict to any schema.\n   *\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n}\n","/**\n * Restrict value to be type of number.\n */\n\nimport RestrictBase from './base';\nimport {\n  isNaN,\n  isNumber,\n  isInfinity,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictNumberSchema extends RestrictBase {\n  // Whether the detected number is allowed to be NaN. By default, it's not allowd.\n  isAllowNaN = false;\n  // Whether the detected number is allowed to be Infinity or -Infinity, By default,\n  // is't not allowd.\n  isAllowInfinity = false;\n\n  /**\n   * Allow the detected number to be NaN.\n   */\n  enableAllowNaN() {\n    this.isAllowNaN = true;\n  }\n\n  /**\n   * Allow the detected number to be Infinity or -Infinity.\n   */\n  enableAllowInfinity() {\n    this.isAllowInfinity = true;\n  }\n\n  /**\n   * Check the detected value whether meets this \"number-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    const { isAllowNaN, isAllowInfinity } = this;\n\n    if (isNaN(val) && !isAllowNaN) {\n      throw this.getError('value is not allowed to be NaN');\n    }\n\n    if (isInfinity(val) && !isAllowInfinity) {\n      throw this.getError('value is not allowed to be Infinity');\n    }\n\n    if (!isNumber(val) && !isNotRequired(val)) {\n      throw this.getError('value should be a type of number');\n    }\n  }\n}\n","/**\n * This is for number, to restrict the detected number is non-empty,\n * which means it's not undefined, null or NaN. This is differet from\n * the \"required\" strict, the \"required\" strict is for non-number value.\n */\n\nimport RestrictBase from './base';\nimport { isNaN, isNotRequired } from '../util/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"number-required\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n\n    // If required restrict is added for number schema, then the detected value\n    // cann't be NaN.\n    if (isNaN(val)) {\n      throw this.getError('value is required and should not be NaN');\n    }\n  }\n}\n","/**\n * This is for number, to restrict the max value of the detected number.\n */\n\nimport RestrictBase from './base';\nimport { isNumber } from '../util/is';\n\nexport default class RestrictNumberMax extends RestrictBase {\n  /**\n   * @param {Number}  max      The max value of the detected number.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the\n   * interval is closed, which means the detected number can be equal to max.\n   * When closed is exactly false, the interval will be opened.\n   */\n  constructor(max, closed) {\n    super();\n\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be a type of number');\n    }\n\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  /**\n   * Check the detected value whether meets this \"number-max\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.closed && val > this.max) {\n      throw this.getError(`value should be less than or equal to ${this.max}`);\n    }\n\n    if (!this.closed && val >= this.max) {\n      throw this.getError(`value should be less than ${this.max}`);\n    }\n  }\n}\n","/**\n * This is for number, to restrict the min value of the detected number.\n */\n\nimport RestrictBase from './base';\nimport { isNumber } from '../util/is';\n\nexport default class RestrictNumberMin extends RestrictBase {\n  /**\n   * @param {Number}  min      The min value of the detected number.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the\n   * interval is closed, which means the detected number can be equal to min.\n   * When closed is exactly false, the interval will be opened.\n   */\n  constructor(min, closed) {\n    super();\n\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a type of number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  /**\n   * Check the detected value whether meets this \"number-min\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.closed && val < this.min) {\n      throw this.getError(`value should be greater than or equal to ${this.min}`);\n    }\n\n    if (!this.closed && val <= this.min) {\n      throw this.getError(`value should be greater than ${this.min}`);\n    }\n  }\n}\n","/**\n * This is for number, to restrict the detected number to be\n * an integer.\n */\n\nimport RestrictBase from './base';\nimport { isInt } from '../util/is';\n\nexport default class RestrictNumberInt extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"number-int\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (isInt(val) === false) {\n      throw this.getError('value should be an integer');\n    }\n  }\n}\n","/**\n * This is for number, to restrict the detected number to be an even integer.\n */\n\nimport RestrictBase from './base';\n\nexport default class RestrictNumberEven extends RestrictBase {\n  /**\n   * Check the detected number whether meets this \"number-even\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (val % 2 !== 0) {\n      throw this.getError('value should be an even integer');\n    }\n  }\n}\n","/**\n * This is for number, to restrict the detected number to be an odd integer.\n */\n\nimport RestrictBase from './base';\n\nexport default class RestrictNumberOdd extends RestrictBase {\n  /**\n   * Check the detected number whether meets this \"number-odd\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (Math.abs(val) % 2 !== 1) {\n      throw this.getError('value should be an odd integer');\n    }\n  }\n}\n","import {\n  isString,\n  isStringNumber,\n} from '../util/is';\nimport { TYPE } from '../util/constants';\nimport RestrictNumberSchema from '../restrict/number-schema';\nimport RestrictNumberRequired from '../restrict/number-required';\nimport RestrictEnum from '../restrict/enum';\nimport RestrictNumberMax from '../restrict/number-max';\nimport RestrictNumberMin from '../restrict/number-min';\nimport RestrictNumberInt from '../restrict/number-int';\nimport RestrictNumberEven from '../restrict/number-even';\nimport RestrictNumberOdd from '../restrict/number-odd';\nimport SchemaBase from './base';\n\nexport default class SchemaNumber extends SchemaBase {\n  type = TYPE.number;\n  isAllowString = false;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictNumberSchema();\n    this.lastRestrict = this.typeRestrict;\n  }\n\n  /**\n   * Set the default return value of validate when the detected value is empty.\n   *\n   * @param {*} args[0] The default return value.\n   * @param {*} args[1] The execute context of value when value is a function.\n   */\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('default arguments should not be empty');\n    }\n\n    const [value, ctx] = args;\n\n    this.defaultConfig = {\n      ctx,\n      value,\n      enable: true,\n      strict: false,\n    };\n\n    return this;\n  }\n\n  /**\n   * Add an \"enum\" restrict to boolean schema.\n   *\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"required\" restrict to number schema.\n   */\n  required() {\n    this.requiredRestrict = new RestrictNumberRequired();\n    this.lastRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  /**\n   * By default, number schema doesn't allow the detected value to be NaN. If\n   * allowNaN method is called, then NaN will be allowd.\n   */\n  allowNaN() {\n    this.typeRestrict.enableAllowNaN();\n    return this;\n  }\n\n  /**\n   * By default, number schema doesn't allow the detected value to be Infinity.\n   * If allowInfinity method is called, then Infinity will be allowd.\n   */\n  allowInfinity() {\n    this.typeRestrict.enableAllowInfinity();\n    return this;\n  }\n\n  /**\n   * By default, number schema doesn't allow the detected value to be number\n   * style string. For example, a string \"123\" is not allowed. If allowString\n   * method is called, then number schema will try to parse string to number.\n   */\n  allowString() {\n    this.isAllowString = true;\n    return this;\n  }\n\n  /**\n   * Add a \"min-number\" restrict for detected number.\n   *\n   * @param {Number}  min      The min value of detected number.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the value of the detected number can be equal to min. When\n   * closed is exactly false, the interval will be opened.\n   */\n  min(min, closed) {\n    const restrict = new RestrictNumberMin(min, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"max-number\" restrict to number schema.\n   *\n   * @param {Number}  max      The max value of detected number.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the value of the detected number can be equal to max. When\n   * closed is exactly false, the interval will be opened.\n   */\n  max(max, closed) {\n    const restrict = new RestrictNumberMax(max, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add an \"int-number\" restrict to number schema.\n   */\n  int() {\n    const restrict = new RestrictNumberInt();\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  even() {\n    const restrict = new RestrictNumberEven();\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  odd() {\n    const restrict = new RestrictNumberOdd();\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * @override\n   * Validate value.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    let value = val;\n\n    // If allowString is called, then preparse string to number.\n    if (\n      this.isAllowString\n      && isString(val)\n      && isStringNumber(val)\n    ) {\n      value = Number(val);\n    }\n\n    return super.validate(value);\n  }\n}\n","/**\n * Restrict value to be type of string.\n */\n\nimport RestrictBase from './base';\nimport {\n  isString,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictStringSchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"string-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (!isString(val) && !isNotRequired(val)) {\n      throw this.getError('value should be a type of string');\n    }\n  }\n}\n","/**\n * Restrict the max length of detected value. The detected value\n * can be string or array.\n */\n\nimport RestrictBase from './base';\nimport { isNumber } from '../util/is';\n\nexport default class RestrictLengthMax extends RestrictBase {\n  /**\n   * @param {Number}  max      The max length of detected value.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected value can be equal to max. When\n   * closed is exactly false, the interval will be opened.\n   */\n  constructor(max, closed) {\n    super();\n\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be a type of number');\n    }\n\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  /**\n   * Check the detected value whether meets this \"length-max\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.closed && val.length > this.max) {\n      throw this.getError(`value length should be less than or equal to ${this.max}`);\n    }\n\n    if (!this.closed && val.length >= this.max) {\n      throw this.getError(`value length should be less than ${this.max}`);\n    }\n\n    return true;\n  }\n}\n","/**\n * Restrict the min length of detected value. The detected value\n * can be string or array.\n */\n\nimport RestrictBase from './base';\nimport { isNumber } from '../util/is';\n\nexport default class RestrictLengthMin extends RestrictBase {\n  /**\n   * @param {Number}  min      The min length of detected value.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected value can be equal to min. When\n   * closed is exactly false, the interval will be opened.\n   */\n  constructor(min, closed) {\n    super();\n\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a type of number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  /**\n   * Check the detected value whether meets this \"length-min\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.closed && val.length < this.min) {\n      throw this.getError(`value length should be greater than or equal to ${this.min}`);\n    }\n\n    if (!this.closed && val.length <= this.min) {\n      throw this.getError(`value length should greater than ${this.min}`);\n    }\n\n    return true;\n  }\n}\n","/**\n * Restrict string format by a regular expression.\n */\n\nimport RestrictBase from './base';\nimport { isRegExp } from '../util/is';\n\nexport default class RestrictStringPattern extends RestrictBase {\n  pattern = null;\n\n  /**\n   * @param {RegExp} pattern The regular expression to restrict the format of string.\n   */\n  constructor(pattern) {\n    super();\n\n    if (isRegExp(pattern) === false) {\n      throw new TypeError('pattern should be an RegExp');\n    }\n\n    this.pattern = pattern;\n  }\n\n  /**\n   * Check the detected value whether meets this \"string-pattern\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (!this.pattern.test(val)) {\n      throw this.getError(`value should match pattern ${this.pattern.toString()}`);\n    }\n  }\n}\n","import { TYPE } from '../util/constants';\nimport RestrictStringSchema from '../restrict/string-schema';\nimport RestrictEnum from '../restrict/enum';\nimport RestrictLengthMax from '../restrict/length-max';\nimport RestrictLengthMin from '../restrict/length-min';\nimport RestrictStringPattern from '../restrict/string-pattern';\nimport SchemaBase from './base';\n\nexport default class SchemaString extends SchemaBase {\n  type = TYPE.string;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictStringSchema();\n    this.lastRestrict = this.typeRestrict;\n  }\n\n  /**\n   * Add an \"enum\" restrict to string schema.\n   *\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"min-length\" restrict to string schema.\n   *\n   * @param {Number}  min      The min length of detected string.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected string can be equal to min. When\n   * closed is exactly false, the interval will be opened.\n   */\n  min(min, closed) {\n    const restrict = new RestrictLengthMin(min, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"max-length\" restrict to string schema.\n   *\n   * @param {Number}  max      The max length of detected string.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected string can be equal to max. When\n   * closed is exactly false, the interval will be opened.\n   */\n  max(max, closed) {\n    const restrict = new RestrictLengthMax(max, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"pattern\" string to string schema.\n   *\n   * @param {RegExp} pattern RegExp to restrict the format of string.\n   */\n  pattern(pattern) {\n    const restrict = new RestrictStringPattern(pattern);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n}\n","/**\n * Restrict value to be type of boolean.\n */\n\nimport RestrictBase from './base';\nimport {\n  isBoolean,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictBooleanSchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"boolean-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    // When the detected value isn't boolean, null or undefined, validation\n    // will be fail. Otherwise, validation will be success.\n    if (!isBoolean(val) && !isNotRequired(val)) {\n      throw this.getError('value should be a type of boolean');\n    }\n  }\n}\n","import { TYPE } from '../util/constants';\nimport RestrictBooleanSchema from '../restrict/boolean-schema';\nimport RestrictEnum from '../restrict/enum';\nimport SchemaBase from './base';\n\nexport default class SchemaBoolean extends SchemaBase {\n  type = TYPE;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictBooleanSchema();\n    this.lastRestrict = this.typeRestrict;\n  }\n\n  /**\n   * Add an \"enum\" restrict to boolean schema.\n   *\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Set the default return value of validate when the detected value is empty.\n   *\n   * @param {*} args[0] The default return value.\n   * @param {*} args[1] The execute context of value when value is a function.\n   */\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('default arguments should not be empty');\n    }\n\n    const [value, ctx] = args;\n\n    this.defaultConfig = {\n      ctx,\n      value,\n      enable: true,\n      strict: false,\n    };\n\n    return this;\n  }\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","/**\n * Get key chain string.\n * @example\n * const keyChainStr = getKeyStr([\n *   {\n *     type: 'prop',\n *     key: 'peoples',\n *   },\n *   {\n *     type: 'index',\n *     key: 2,\n *   },\n *   {\n *     type: 'prop',\n *     key: 'friend',\n *   },\n *   {\n *     type: 'prop',\n *     key: 'first name',\n *   },\n * ]);\n * assert(keyChainStr === 'peoples[0].friend[\\'first name\\']');\n *\n * @param {Array} keyChain Key chain list.\n */\nexport default function getKeyStr(keyChain) {\n  const propReg = /^[_$a-z][_$a-z\\d]*$/i;\n  let result = '';\n\n  keyChain.forEach(({ type, key }) => {\n    if (type === 'prop' && propReg.test(key)) {\n      if (result) {\n        result += `.${key}`;\n      } else {\n        result += key;\n      }\n    } else if (type === 'prop') {\n      result += `['${key}']`;\n    } else if (type === 'index') {\n      result += `[${key}]`;\n    }\n  });\n\n  return result;\n}\n","/**\n * Restrict value to be type of object.\n */\n\nimport RestrictBase from './base';\nimport {\n  isObject,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictObjectSchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"object-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (isObject(val) || isNotRequired(val)) {\n      return true;\n    }\n\n    throw this.getError('value should be a type of object');\n  }\n}\n","import {\n  isObject,\n  isNotRequired,\n} from '../util/is';\nimport {\n  TYPE,\n  useKeyChainSymbol,\n} from '../util/constants';\nimport getKeyStr from '../util/get-key-str';\nimport RestrictObjectSchema from '../restrict/object-schema';\nimport ValidateError from '../util/validate-error';\nimport SchemaBase from './base';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport default class SchemaObject extends SchemaBase {\n  type = TYPE.object;\n  config = null;\n  isStripUnknown = false;\n  isAllowUnknown = false;\n\n  constructor(config) {\n    super();\n    this.typeRestrict = new RestrictObjectSchema();\n    this.lastRestrict = this.typeRestrict;\n\n    // If config is passed non-object, it means that the key-value structure\n    // is no need to restrct.\n    if (isObject(config)) {\n      const pureConfig = {};\n\n      // Filter the keys that corresponding value is an instance of SchemaBase.\n      // This is for the purpose that allow config include value that is not an\n      // instance of SchemaBase, and ingore them.\n      Object.keys(config).forEach((key) => {\n        if (config[key] instanceof SchemaBase) {\n          pureConfig[key] = config[key];\n        }\n      });\n      this.config = pureConfig;\n    }\n  }\n\n  /**\n   * If stripUnkown is called, then the return result of validate method will\n   * not include the keys that not included in config.\n   */\n  stripUnknown() {\n    this.isStripUnknown = true;\n    return this;\n  }\n\n  /**\n   * By default, the detected object is not allowed to include the unknown keys\n   * that is not included in config. If allowUnknown is called, then these\n   * unknown keys will be allowed, and these unknown key-values will be returned\n   * in validate result.\n   */\n  allowUnknown() {\n    this.isAllowUnknown = true;\n    return this;\n  }\n\n  /**\n   * Validate value.\n   *\n   * @param {*}      obj         The value to validate.\n   * @param {Symbol} useKeyChain If pass the special symbol, the keyChain param\n   * will be used.\n   * @param {Array}  keyChain    The passed key chain of parent keys.\n   */\n  validate(obj, useKeyChain, keyChain) {\n    // When it's not required, and the detected value is undefined or null,\n    // then it's no need to validate any more, just return default value or\n    // default value after formated.\n    if (!this.requiredRestrict && isNotRequired(obj)) {\n      return this.getReturnValue(obj);\n    }\n\n    try {\n      this.checkType(obj);\n      this.checkRequired(obj);\n      this.checkRestricts(obj);\n\n      return this.getReturnValue(this.validateByRecurse(\n        obj,\n        useKeyChain === useKeyChainSymbol ? keyChain : undefined,\n      ));\n    } catch (error) {\n      this.throwErrorWithoutKeyChainIfNeeded(error);\n      const errorForAll = this.getErrorForAll(error.message);\n\n      if (errorForAll) {\n        throw errorForAll;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * @private\n   * Traverse each key of the object and validate each value recursively.\n   *\n   * @param {Array} obj           The detected object.\n   * @param {Array} [keyChain=[]] The key chain of ancestors to give friendly\n   * error prompts.\n   * @returns {Object}            The return value if validate pass.\n   */\n  validateByRecurse(obj, keyChain = []) {\n    if (this.config === null) {\n      return obj;\n    }\n\n    const result = {};\n    const chain = keyChain;\n    const keys = Object.keys(this.config);\n\n    keys.forEach((key) => {\n      const schema = this.config[key];\n\n      if (!schema.requiredRestrict && !hasOwnProperty.call(obj, key)) {\n        this.setResultWhenDefaultEnabled({\n          key,\n          result,\n        });\n      } else {\n        result[key] = this.validateObjectByKey(obj, {\n          key,\n          chain,\n        });\n      }\n    });\n    if (!this.isStripUnknown) {\n      Object\n        .keys(obj)\n        .forEach((key) => {\n          const notIncluded = keys.includes(key) === false;\n\n          if (notIncluded && !this.isAllowUnknown) {\n            throw new ValidateError(`the key \\`${key}\\` is not allowed`);\n          }\n\n          if (notIncluded) {\n            result[key] = obj[key];\n          }\n        });\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   * Validate an key-value of the detected object.\n   *\n   * @param {object} obj            The detected object.\n   * @param {object} options\n   * @param {string} options.key    The prop key.\n   * @param {array}  options.chain  The key chain of ancestors to give friendly\n   * error prompts.\n   */\n  validateObjectByKey(obj, options) {\n    const { key, chain } = options;\n    const schema = this.config[key];\n    const keyOption = { key, type: 'prop' };\n\n    try {\n      return schema.validate(\n        obj[key],\n        useKeyChainSymbol,\n        [\n          ...chain,\n          keyOption,\n        ],\n      );\n    } catch (error) {\n      this.throwErrorWithoutKeyChainIfNeeded(error);\n      const keyChainStr = `\"${getKeyStr([...chain, keyOption])}\": `;\n\n      throw new ValidateError(\n        `${keyChainStr}${error.message}`,\n        { final: true },\n      );\n    }\n  }\n\n  /**\n   * @private\n   * Set some key-values of return value when default method was called.\n   *\n   * @param {object} params\n   * @param {string} params.key    The prop key.\n   * @param {object} params.result The value that will be returned.\n   * @returns {void}\n   */\n  setResultWhenDefaultEnabled(params) {\n    const { key, result } = params;\n\n    const schema = this.config[key];\n    if (schema.defaultConfig.enable) {\n      result[key] = schema.getDefaultReturnValue(undefined);\n    }\n  }\n}\n","/**\n * Restrict value to be type of array.\n */\n\nimport RestrictBase from './base';\nimport {\n  isArray,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictArraySchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"array-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    // When the detected value isn't array, null or undefined, validation\n    // will be fail. Otherwise, validation will be success.\n    if (!isArray(val) && !isNotRequired(val)) {\n      throw this.getError('value should be a type of array');\n    }\n  }\n}\n","/**\n * Class for array schema.\n */\n\nimport {\n  isNotRequired,\n} from '../util/is';\nimport {\n  TYPE,\n  useKeyChainSymbol,\n} from '../util/constants';\nimport getKeyStr from '../util/get-key-str';\nimport ValidateError from '../util/validate-error';\nimport RestrictArraySchema from '../restrict/array-schema';\nimport RestrictLengthMin from '../restrict/length-min';\nimport RestrictLengthMax from '../restrict/length-max';\nimport SchemaBase from './base';\n\nexport default class SchemaArray extends SchemaBase {\n  type = TYPE.array;\n  itemSchema = null;\n\n  /**\n   * @param {SchemaBase} itemSchema The schema defined for every item of array.\n   * If itemSchema isn't instanceof SchemaBase, then it will be ignored, this\n   * means that the detected array can include any type value.\n   */\n  constructor(itemSchema) {\n    super();\n    this.typeRestrict = new RestrictArraySchema();\n    this.lastRestrict = this.typeRestrict;\n\n    // Only handle itemSchema when it's instanceof SchemaBase.\n    if (itemSchema instanceof SchemaBase) {\n      this.itemSchema = itemSchema;\n    }\n  }\n\n  /**\n   * Add a \"min-length\" restrict to array schema.\n   *\n   * @param {Number}  min      The min length of detected array.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected array can be equal to min. When\n   * closed is exactly false, the interval will be opened.\n   */\n  min(min, closed) {\n    const restrict = new RestrictLengthMin(min, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"max-length\" restrict to array schema.\n   *\n   * @param {Number}  max      The max length of detected array.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected array can be equal to max. When\n   * closed is exactly false, the interval will be opened.\n   */\n  max(max, closed) {\n    const restrict = new RestrictLengthMax(max, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Validate value.\n   *\n   * @param {*}      array       The value to validate.\n   * @param {Symbol} useKeyChain If pass the special symbol, the keyChain param will be used.\n   * @param {Array}  keyChain    The passed key chain of parent keys.\n   */\n  validate(array, useKeyChain, keyChain) {\n    // When it's not required, and the detected value is undefined or null, then it's no need\n    // to validate any more, just return default value or default value after formated.\n    if (!this.requiredRestrict && isNotRequired(array)) {\n      return this.getReturnValue(array);\n    }\n\n    try {\n      this.checkType(array);\n      this.checkRequired(array);\n      this.checkRestricts(array);\n\n      return this.getReturnValue(this.validateByRecurse(\n        array,\n        useKeyChain === useKeyChainSymbol ? keyChain : undefined,\n      ));\n    } catch (error) {\n      this.throwErrorWithoutKeyChainIfNeeded(error);\n      const errorForAll = this.getErrorForAll(error.message);\n\n      if (errorForAll) {\n        throw errorForAll;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * @private\n   * Traverse each item of the array and validate each member recursively.\n   *\n   * @param {Array} array         The detected array.\n   * @param {Array} [keyChain=[]] The key chain of ancestors to give friendly error prompts.\n   * @returns {Array}             The return value if validate pass.\n   */\n  validateByRecurse(array, keyChain = []) {\n    const chain = keyChain;\n    const { itemSchema } = this;\n\n    if (itemSchema) {\n      return array.map((_, index) => this.validateItem({\n        index,\n        array,\n        chain,\n      }));\n    }\n\n    // Return a shallow copy of the detected array.\n    return [...array];\n  }\n\n  /**\n   * @private\n   * Validate an item of the detected array.\n   *\n   * @param {object} params\n   * @param {number} params.index  The index of the item in array.\n   * @param {array}  params.array  The detected array.\n   * @param {array}  params.chain  The key chain of ancestors.\n   */\n  validateItem(params) {\n    const {\n      index,\n      array,\n      chain,\n    } = params;\n    const { itemSchema } = this;\n\n    try {\n      return itemSchema.validate(\n        array[index],\n        useKeyChainSymbol,\n        [...chain, { type: 'index', key: index }],\n      );\n    } catch (error) {\n      this.throwErrorWithoutKeyChainIfNeeded(error);\n      const keyOption = {\n        type: 'index',\n        key: index,\n      };\n      const keyChainStr = `\"${getKeyStr([...chain, keyOption])}\": `;\n\n      throw new ValidateError(\n        `${keyChainStr}${error.message}`,\n        { final: true },\n      );\n    }\n  }\n}\n","/**\n * Mixed schema, it means you can combine several schemas into one schema.\n */\n\nimport SchemaBase from './base';\n\nexport default class SchemaMixed extends SchemaBase {\n  schemas = null;\n\n  /**\n   * @param {Array<SchemaBase>} schemas The allowed schemas.\n   */\n  constructor(...schemas) {\n    super();\n\n    if (schemas.length === 0) {\n      throw new RangeError('mixed arguments should not be empty');\n    }\n\n    this.schemas = schemas;\n  }\n\n  /**\n   * Validate value.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    let finalError = null;\n\n    for (let i = 0; i < this.schemas.length; i += 1) {\n      try {\n        return this.schemas[i].validate(val);\n      } catch (error) {\n        finalError = error;\n      }\n    }\n\n    throw finalError;\n  }\n}\n","import {\n  SchemaAny,\n  SchemaNumber,\n  SchemaString,\n  SchemaBoolean,\n  SchemaObject,\n  SchemaArray,\n  SchemaMixed,\n} from './schema';\n\nexport function any() {\n  return new SchemaAny();\n}\n\nexport function number() {\n  return new SchemaNumber();\n}\n\nexport function string() {\n  return new SchemaString();\n}\n\nexport function boolean() {\n  return new SchemaBoolean();\n}\n\nexport function object(config) {\n  return new SchemaObject(config);\n}\n\nexport function array(itemSchema) {\n  return new SchemaArray(itemSchema);\n}\n\nexport function mixed(...schemas) {\n  return new SchemaMixed(...schemas);\n}\n\nexport default {\n  any,\n  number,\n  string,\n  boolean,\n  object,\n  array,\n  mixed,\n};\n"],"names":["_setPrototypeOf","o","p","Object","setPrototypeOf","__proto__","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","prototype","toString","call","e","_construct","Parent","args","Class","isNativeReflectConstruct","a","push","apply","instance","Function","bind","arguments","_classCallCheck","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_inherits","subClass","superClass","create","constructor","value","_typeof","obj","Symbol","iterator","_possibleConstructorReturn","self","ReferenceError","assertThisInitialized","_getPrototypeOf","getPrototypeOf","TYPE","number","string","boolean","object","array","any","useKeyChainSymbol","_get","property","receiver","get","base","hasOwnProperty","superPropBase","desc","getOwnPropertyDescriptor","_wrapNativeSuper","_cache","Map","undefined","fn","indexOf","has","set","Wrapper","this","ValidateError","message","options","custom","final","Error","getType","val","str","substring","isNaN","isString","isNumber","isObject","isNotRequired","isUndefined","isNull","isEmpty","type","keys","isFunction","isCustomError","error","RestrictBase","errorConfig","ctx","originMessage","RestrictAnySchema","RestrictAnyRequired","strict","getError","RestrictEnum","enumValues","values","RangeError","JSON","stringify","RestrictRequired","RestrictCustom","restrictFn","result","SchemaBase","restricts","typeRestrict","requiredRestrict","lastRestrict","defaultConfig","enable","formatterConfig","formatter","errorForAllConfig","getReturnValue","checkType","checkRequired","checkRestricts","errorForAll","getErrorForAll","validate","restrict","ensureMessageType","setErrorMessage","getDefaultReturnValue","getReturnValueWithoutStrict","originalMessage","forEach","isFinalError","SchemaAny","_this","RestrictNumberSchema","isAllowNaN","isAllowInfinity","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","isInfinity","RestrictNumberMax","max","closed","RestrictNumberMin","min","RestrictNumberInt","isInt","RestrictNumberEven","RestrictNumberOdd","Math","abs","SchemaNumber","isAllowString","RestrictNumberRequired","enableAllowNaN","enableAllowInfinity","test","isStringNumber","RestrictStringSchema","RestrictLengthMax","RestrictLengthMin","RestrictStringPattern","pattern","RegExp","SchemaString","RestrictBooleanSchema","isBoolean","SchemaBoolean","_arrayLikeToArray","arr","len","arr2","Array","_toConsumableArray","isArray","arrayLikeToArray","arrayWithoutHoles","iter","from","iterableToArray","minLen","n","slice","name","unsupportedIterableToArray","nonIterableSpread","getKeyStr","keyChain","propReg","RestrictObjectSchema","SchemaObject","config","isStripUnknown","isAllowUnknown","pureConfig","useKeyChain","validateByRecurse","throwErrorWithoutKeyChainIfNeeded","chain","_this2","validateObjectByKey","setResultWhenDefaultEnabled","notIncluded","includes","schema","keyOption","keyChainStr","params","RestrictArraySchema","SchemaArray","itemSchema","map","_","index","validateItem","SchemaMixed","schemas","finalError","mixed"],"mappings":"8OAAe,SAASA,EAAgBC,EAAGC,GAMzC,OALAF,EAAkBG,OAAOC,gBAAkB,SAAyBH,EAAGC,GAErE,OADAD,EAAEI,UAAYH,EACPD,IAGcA,EAAGC,GCNb,SAASI,IACtB,GAAuB,oBAAZC,UAA4BA,QAAQC,UAAW,OAAO,EACjE,GAAID,QAAQC,UAAUC,KAAM,OAAO,EACnC,GAAqB,mBAAVC,MAAsB,OAAO,EAExC,IAEE,OADAC,KAAKC,UAAUC,SAASC,KAAKP,QAAQC,UAAUG,KAAM,IAAI,iBAClD,EACP,MAAOI,GACP,OAAO,GCPI,SAASC,EAAWC,EAAQC,EAAMC,GAc/C,OAZEH,EADEI,IACWb,QAAQC,UAER,SAAoBS,EAAQC,EAAMC,GAC7C,IAAIE,EAAI,CAAC,MACTA,EAAEC,KAAKC,MAAMF,EAAGH,GAChB,IACIM,EAAW,IADGC,SAASC,KAAKH,MAAMN,EAAQI,IAG9C,OADIF,GAAOf,EAAeoB,EAAUL,EAAMP,WACnCY,IAIOD,MAAM,KAAMI,WChBjB,SAASC,EAAgBJ,EAAUK,GAChD,KAAML,aAAoBK,GACxB,MAAM,IAAIC,UAAU,qCCFxB,SAASC,EAAkBC,EAAQC,GACjC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CACrC,IAAIE,EAAaH,EAAMC,GACvBE,EAAWC,WAAaD,EAAWC,aAAc,EACjDD,EAAWE,cAAe,EACtB,UAAWF,IAAYA,EAAWG,UAAW,GACjDpC,OAAOqC,eAAeR,EAAQI,EAAWK,IAAKL,IAInC,SAASM,EAAab,EAAac,EAAYC,GAG5D,OAFID,GAAYZ,EAAkBF,EAAYjB,UAAW+B,GACrDC,GAAab,EAAkBF,EAAae,GACzCf,ECZM,SAASgB,EAAUC,EAAUC,GAC1C,GAA0B,mBAAfA,GAA4C,OAAfA,EACtC,MAAM,IAAIjB,UAAU,sDAGtBgB,EAASlC,UAAYT,OAAO6C,OAAOD,GAAcA,EAAWnC,UAAW,CACrEqC,YAAa,CACXC,MAAOJ,EACPP,UAAU,EACVD,cAAc,KAGdS,GAAY3C,EAAe0C,EAAUC,GCb5B,SAASI,EAAQC,GAa9B,OATED,EADoB,mBAAXE,QAAoD,iBAApBA,OAAOC,SACtC,SAAiBF,GACzB,cAAcA,GAGN,SAAiBA,GACzB,OAAOA,GAAyB,mBAAXC,QAAyBD,EAAIH,cAAgBI,QAAUD,IAAQC,OAAOzC,UAAY,gBAAkBwC,IAI9GA,GCXF,SAASG,EAA2BC,EAAM1C,GACvD,OAAIA,GAA2B,WAAlBqC,EAAQrC,IAAsC,mBAATA,ECHrC,SAAgC0C,GAC7C,QAAa,IAATA,EACF,MAAM,IAAIC,eAAe,6DAG3B,OAAOD,EDEAE,CAAsBF,GAHpB1C,EEJI,SAAS6C,EAAgB1D,GAItC,OAHA0D,EAAkBxD,OAAOC,eAAiBD,OAAOyD,eAAiB,SAAyB3D,GACzF,OAAOA,EAAEI,WAAaF,OAAOyD,eAAe3D,KAEvBA,GCJlB,IAAM4D,EAAO,CAClBC,OAAQ,SACRC,OAAQ,SACRC,QAAS,UACTC,OAAQ,SACRC,MAAO,QACPC,IAAK,OAGMC,EAAoBf,OAAO,sBCRzB,SAASgB,EAAKrC,EAAQsC,EAAUC,GAiB7C,OAfEF,EADqB,oBAAZ9D,SAA2BA,QAAQiE,IACrCjE,QAAQiE,IAER,SAAcxC,EAAQsC,EAAUC,GACrC,IAAIE,ECLK,SAAwBR,EAAQK,GAC7C,MAAQnE,OAAOS,UAAU8D,eAAe5D,KAAKmD,EAAQK,IAEpC,QADfL,EAASL,EAAeK,MAI1B,OAAOA,EDDQU,CAAc3C,EAAQsC,GACjC,GAAKG,EAAL,CACA,IAAIG,EAAOzE,OAAO0E,yBAAyBJ,EAAMH,GAEjD,OAAIM,EAAKJ,IACAI,EAAKJ,IAAI1D,KAAKyD,GAGhBK,EAAK1B,SAIJlB,EAAQsC,EAAUC,GAAYvC,GEd7B,SAAS8C,EAAiB3D,GACvC,IAAI4D,EAAwB,mBAARC,IAAqB,IAAIA,SAAQC,EA8BrD,OA5BAH,EAAmB,SAA0B3D,GAC3C,GAAc,OAAVA,ICRkC+D,EDQE/D,GCPsB,IAAzDM,SAASZ,SAASC,KAAKoE,GAAIC,QAAQ,kBDOQ,OAAOhE,ECR5C,IAA2B+D,EDUtC,GAAqB,mBAAV/D,EACT,MAAM,IAAIW,UAAU,sDAGtB,QAAsB,IAAXiD,EAAwB,CACjC,GAAIA,EAAOK,IAAIjE,GAAQ,OAAO4D,EAAOP,IAAIrD,GAEzC4D,EAAOM,IAAIlE,EAAOmE,GAGpB,SAASA,IACP,OAAO9E,EAAUW,EAAOQ,UAAWiC,EAAe2B,MAAMtC,aAW1D,OARAqC,EAAQ1E,UAAYT,OAAO6C,OAAO7B,EAAMP,UAAW,CACjDqC,YAAa,CACXC,MAAOoC,EACPjD,YAAY,EACZE,UAAU,EACVD,cAAc,KAGXlC,EAAekF,EAASnE,KAGTA,yaEnCLqE,2CAIPC,SAASC,yDAAU,4BACvBD,IAJRE,QAAS,IACTC,OAAQ,QAOFF,EAFFC,OAAAA,kBAEED,EADFE,MAAAA,yBAGGD,OAASA,IACTC,MAAQA,gIAZ0BC,QCEnChF,EAAaV,OAAOS,UAApBC,SAED,SAASiF,EAAQC,OAChBC,EAAMnF,EAASC,KAAKiF,UACnBC,EAAIC,UAAU,EAAGD,EAAI7D,OAAS,GAWhC,SAAS+D,EAAMH,UACbA,GAAQA,EAGV,SAASI,EAASJ,SACD,iBAARA,EAGT,SAASK,EAASL,SACD,iBAARA,EAsBT,SAASM,EAASN,SACC,WAAjBD,EAAQC,GAOV,SAASO,EAAcP,UA/CvB,SAAqBA,eACXd,IAARc,EA+CAQ,CAAYR,IA5Cd,SAAgBA,UACN,OAARA,EA2CoBS,CAAOT,GAG7B,SAASU,EAAQV,OAChBW,EAAOZ,EAAQC,SAER,WAATW,EACiC,IAA5BvG,OAAOwG,KAAKZ,GAAK5D,OAGb,UAATuE,EACoB,IAAfX,EAAI5D,OAIXmE,EAAcP,IACXG,EAAMH,IACE,KAARA,EAUA,SAASa,EAAWb,SACD,aAAjBD,EAAQC,GA0BV,SAASc,EAAcC,UACrBA,aAAiBtB,GAAiBsB,EAAMnB,WCzG5BoB,yCAInBC,YAAc,CACZC,IAAK,KACLxB,QAAS,sDASKA,EAASwB,QAClBD,YAAc,CACjBC,IAAAA,EACAxB,QAAAA,oCAUKyB,SACkB3B,KAAKyB,YAAtBvB,IAAAA,QAASwB,IAAAA,WAEbL,EAAWnB,GACN,IAAID,EACTC,EAAQ3E,KAAKmG,EAAKC,GAClB,CAAEvB,QAAQ,IAIVF,GAAWU,EAASV,GACf,IAAID,EACTC,EACA,CAAEE,QAAQ,IAIP,IAAIH,EAAc0B,kbC5CRC,0IAOV,SAPoCJ,yaCM1BK,2CAQPC,2CAPZA,QAAS,IASFA,QAAoB,IAAXA,+CAQPtB,OACCsB,EAAW9B,KAAX8B,WAIHA,IAAWf,EAAcP,IAAQG,EAAMH,UACpCR,KAAK+B,SAAS,8DAGP,IAAXD,GAAmBZ,EAAQV,SACvBR,KAAK+B,SAAS,oDA5BuBP,yaCR5BQ,8EACnBC,WAAa,gCAKEC,2BAAAA,qBAGS,IAAlBA,EAAOtF,aACH,IAAIuF,WAAW,+CAGlBF,WAAaC,+CAQX1B,OAC+B,IAAlCR,KAAKiC,WAAWrC,QAAQY,SACpBR,KAAK+B,0CAAmCK,KAAKC,UAAUrC,KAAKiC,qBAvB9BT,yaCGrBc,2CAOPR,2CANZA,QAAS,IAQFA,QAAoB,IAAXA,+CAQPtB,OACCsB,EAAW9B,KAAX8B,UAEJA,GAAUZ,EAAQV,SACdR,KAAK+B,SAAS,iDAGjBD,GAAUf,EAAcP,SACrBR,KAAK+B,SAAS,6DAzBoBP,yaCFzBe,2CAYPC,EAAYd,uCAXxBA,IAAM,OACNc,WAAa,MAaoB,IAA3BnB,EAAWmB,SACP,IAAIjG,UAAU,sDAGjBiG,WAAaA,IACbd,IAAMA,+CAQJlB,WAECiC,EAASzC,KAAKwC,WAAWjH,KAAKyE,KAAK0B,IAAKlB,MAG1CI,EAAS6B,IAAWA,QAChBzC,KAAK+B,SAASU,GAEtB,MAAOlB,SAGDvB,KAAK+B,SAASR,EAAMrB,gBAGrB,SA1CiCsB,GCUvBkB,yCACnBC,UAAY,QACZC,aAAe,UACfC,iBAAmB,UAInBC,aAAe,UAGfC,cAAgB,CACdC,QAAQ,EACRlB,QAAQ,EACRJ,IAAK,KACL/D,WAAO+B,QAKTuD,gBAAkB,CAChBvB,SAAKhC,EACLwD,UAAW,SAAA1C,UAAOA,SAKpB2C,kBAAoB,CAClBH,QAAQ,EACRtB,SAAKhC,EACLQ,QAAS,+CAQFM,OAGFR,KAAK6C,kBAAoB9B,EAAcP,UACnCR,KAAKoD,eAAe5C,mBAItB6C,UAAU7C,QACV8C,cAAc9C,QACd+C,eAAe/C,GAEbR,KAAKoD,eAAe5C,GAC3B,MAAOe,MACHD,EAAcC,SACVA,MAGFiC,EAAcxD,KAAKyD,eAAelC,EAAMrB,YAE1CsD,QACIA,QAGFjC,0CAUKf,aAEJ,CACL7C,MAAOqC,KAAK0D,SAASlD,IAEvB,MAAOe,SACA,CACLA,MAAAA,EACA5D,MAAO6C,qCAWJsB,eACFe,iBAAmB,IAAIP,EAAiBR,QACxCgB,aAAe9C,KAAK6C,iBAClB7C,oCASFwC,EAAYd,OACXiC,EAAW,IAAIpB,EAAeC,EAAYd,eAE3CiB,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,mCASHE,EAASwB,eACRkC,kBAAkB1D,QAClB4C,aAAae,gBAAgB3D,EAASwB,GACpC1B,yCAUGE,EAASwB,eACdkC,kBAAkB1D,QAClBiD,kBAAoB,CACvBH,QAAQ,EACR9C,QAAAA,EACAwB,IAAAA,GAGK1B,kEAUErE,2BAAAA,qBACW,IAAhBA,EAAKiB,aACD,IAAI0D,MAAM,6CAGX3C,EAAsBhC,KAAfmG,EAAenG,KAAP+F,EAAO/F,iBACxBoH,cAAgB,CACnBrB,IAAAA,EACA/D,MAAAA,EACAqF,QAAQ,EACRlB,QAAmB,IAAXA,GAGH9B,oCASFkD,EAAWxB,MACS,mBAAdwB,QACH,IAAI3G,UAAU,wDAGjB0G,gBAAkB,CACrBvB,IAAAA,EACAwB,UAAAA,GAGKlD,4CAQMQ,SACcR,KAAK+C,cAAxBC,IAAAA,OAAQlB,IAAAA,SACW9B,KAAKiD,gBAAxBC,IAAAA,UAAWxB,IAAAA,WAEfsB,GAAUlB,GAAUZ,EAAQV,GACvB0C,EAAU3H,KACfmG,EACA1B,KAAK8D,sBAAsBtD,IAIxBR,KAAK+D,4BAA4BvD,iDAQpBA,SACGR,KAAK+C,cAApBpF,IAAAA,MAAO+D,IAAAA,UAEM,mBAAV/D,EACFA,EAAMpC,KAAKmG,EAAKlB,GAGlB7C,yCAQMqG,SAKThE,KAAKmD,kBAHPzB,IAAAA,IACAsB,IAAAA,OACA9C,IAAAA,eAGa,IAAX8C,EACK,KAGL3B,EAAWnB,GACN,IAAID,EAAcC,EAAQ3E,KAAKmG,EAAKsC,IAGtC,IAAI/D,EAAcC,qCAQjBM,UACDR,KAAK4C,aAAac,SAASlD,yCAQtBA,UACPR,KAAK6C,kBAIH7C,KAAK6C,iBAAiBa,SAASlD,0CAQzBA,eACRmC,UAAUsB,SAAQ,SAACN,GACtBA,EAASD,SAASlD,OAEb,4DAUyBe,MPjL7B,SAAsBA,UACpBA,aAAiBtB,GAAiBsB,EAAMlB,MOiLzC6D,CAAa3C,SACTA,KAGJD,EAAcC,SACV,IAAItB,EAAcsB,EAAMrB,QAAS,CAAEG,OAAO,8CAUlCH,OACXU,EAASV,KAAamB,EAAWnB,SAC9B,IAAI3D,UAAU,wGAUIiE,OAClBwC,EAAWhD,KAAK+C,cAAhBC,SACmBhD,KAAKiD,gBAAxBC,IAAAA,UAAWxB,IAAAA,IACf/D,EAAQ6C,SAIRwC,IAAWjC,EAAcP,IAAQG,EAAMH,MACzC7C,EAAQqC,KAAK8D,sBAAsBtD,IAI9B0C,EAAU3H,KAAKmG,EAAK/D,kbCvUVwG,qFACnBhD,KAAO7C,EAAKM,MAILgE,aAAe,IAAIhB,IACnBkB,aAAesB,EAAKxB,0DASlBd,eACFe,iBAAmB,IAAIhB,EAAoBC,QAC3CgB,aAAe9C,KAAK6C,iBAClB7C,+DAQDkC,2BAAAA,sBACAyB,IAAe3B,EAAgBE,eAEhCS,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,YA/B4B0C,yaCElB2B,gLAEnBC,YAAa,IAGbC,iBAAkB,4DAMXD,YAAa,qDAObC,iBAAkB,mCAQhB/D,OACC8D,EAAgCtE,KAAhCsE,WAAYC,EAAoBvE,KAApBuE,mBAEhB5D,EAAMH,KAAS8D,QACXtE,KAAK+B,SAAS,qCTTnB,SAAoBvB,UAEvBA,IAAQgE,OAAOC,mBACZjE,IAAQgE,OAAOE,kBSSdC,CAAWnE,KAAS+D,QAChBvE,KAAK+B,SAAS,2CAGjBlB,EAASL,KAASO,EAAcP,SAC7BR,KAAK+B,SAAS,2CAtCwBP,yaCH7Bc,iIAMV9B,MACHO,EAAcP,SACVR,KAAK+B,SAAS,yDAKlBpB,EAAMH,SACFR,KAAK+B,SAAS,kDAdoBP,yaCFzBoD,2CAOPC,EAAKC,sCAGO,IAAlBjE,EAASgE,SACL,IAAItI,UAAU,6CAGjBsI,IAAMA,IACNC,QAAoB,IAAXA,+CAQPtE,MACHR,KAAK8E,QAAUtE,EAAMR,KAAK6E,UACtB7E,KAAK+B,yDAAkD/B,KAAK6E,UAG/D7E,KAAK8E,QAAUtE,GAAOR,KAAK6E,UACxB7E,KAAK+B,6CAAsC/B,KAAK6E,aA7BbrD,yaCA1BuD,2CAOPC,EAAKF,sCAGO,IAAlBjE,EAASmE,SACL,IAAIzI,UAAU,6CAGjByI,IAAMA,IACNF,QAAoB,IAAXA,+CAQPtE,MACHR,KAAK8E,QAAUtE,EAAMR,KAAKgF,UACtBhF,KAAK+B,4DAAqD/B,KAAKgF,UAGlEhF,KAAK8E,QAAUtE,GAAOR,KAAKgF,UACxBhF,KAAK+B,gDAAyC/B,KAAKgF,aA7BhBxD,yaCC1ByD,iIAMVzE,OACY,IbchB,SAAeA,UACbK,EAASL,IAAQA,EAAM,GAAM,Eaf9B0E,CAAM1E,SACFR,KAAK+B,SAAS,qCARqBP,yaCF1B2D,iIAMV3E,MACHA,EAAM,GAAM,QACRR,KAAK+B,SAAS,0CARsBP,yaCA3B4D,kIAMV5E,MACH6E,KAAKC,IAAI9E,GAAO,GAAM,QAClBR,KAAK+B,SAAS,yCARqBP,0aCS1B+D,uFACnBpE,KAAO7C,EAAKC,SACZiH,eAAgB,IAIT5C,aAAe,IAAIyB,IACnBvB,aAAesB,EAAKxB,sFAShBjH,2BAAAA,qBACW,IAAhBA,EAAKiB,aACD,IAAI0D,MAAM,6CAGX3C,EAAchC,KAAP+F,EAAO/F,iBAEhBoH,cAAgB,CACnBrB,IAAAA,EACA/D,MAAAA,EACAqF,QAAQ,EACRlB,QAAQ,GAGH9B,+DAQDkC,2BAAAA,sBACAyB,IAAe3B,EAAgBE,eAEhCS,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,oDAOF6C,iBAAmB,IAAI4C,OACvB3C,aAAe9C,KAAK6C,iBAClB7C,oDAQF4C,aAAa8C,iBACX1F,yDAQF4C,aAAa+C,sBACX3F,uDASFwF,eAAgB,EACdxF,iCAWLgF,EAAKF,OACDnB,EAAW,IAAIoB,EAAkBC,EAAKF,eAEvCnC,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,iCAWL6E,EAAKC,OACDnB,EAAW,IAAIiB,EAAkBC,EAAKC,eAEvCnC,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,uCAOD2D,EAAW,IAAIsB,cAEhBtC,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,wCAID2D,EAAW,IAAIwB,cAEhBxC,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,uCAID2D,EAAW,IAAIyB,eAEhBzC,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,sCASAQ,OACH7C,EAAQ6C,SAIVR,KAAKwF,eACF5E,EAASJ,IhBtEX,SAAwBA,UACzB,QAAQoF,KAAKpF,KAGTG,EAAM6D,OAAOhE,IgBmEdqF,CAAerF,KAElB7C,EAAQ6G,OAAOhE,gDAGK7C,UAhKgB+E,0aCLrBoD,mIAMVtF,OACFI,EAASJ,KAASO,EAAcP,SAC7BR,KAAK+B,SAAS,2CARwBP,0aCF7BuE,6CAOPlB,EAAKC,sCAGO,IAAlBjE,EAASgE,SACL,IAAItI,UAAU,6CAGjBsI,IAAMA,IACNC,QAAoB,IAAXA,+CAQPtE,MACHR,KAAK8E,QAAUtE,EAAI5D,OAASoD,KAAK6E,UAC7B7E,KAAK+B,gEAAyD/B,KAAK6E,UAGtE7E,KAAK8E,QAAUtE,EAAI5D,QAAUoD,KAAK6E,UAC/B7E,KAAK+B,oDAA6C/B,KAAK6E,aAGxD,SAhCoCrD,0aCA1BwE,6CAOPhB,EAAKF,sCAGO,IAAlBjE,EAASmE,SACL,IAAIzI,UAAU,6CAGjByI,IAAMA,IACNF,QAAoB,IAAXA,+CAQPtE,MACHR,KAAK8E,QAAUtE,EAAI5D,OAASoD,KAAKgF,UAC7BhF,KAAK+B,mEAA4D/B,KAAKgF,UAGzEhF,KAAK8E,QAAUtE,EAAI5D,QAAUoD,KAAKgF,UAC/BhF,KAAK+B,oDAA6C/B,KAAKgF,aAGxD,SAhCoCxD,0aCD1ByE,6CAMPC,uCALZA,QAAU,MAQkB,GAAbA,apB6BOC,aoB5BZ,IAAI5J,UAAU,wCAGjB2J,QAAUA,+CAQR1F,OACFR,KAAKkG,QAAQN,KAAKpF,SACfR,KAAK+B,8CAAuC/B,KAAKkG,QAAQ5K,oBAvBlBkG,0aCC9B4E,uFACnBjF,KAAO7C,EAAKE,SAILoE,aAAe,IAAIkD,KACnBhD,aAAesB,EAAKxB,mFAQnBV,2BAAAA,sBACAyB,IAAe3B,EAAgBE,eAEhCS,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,iCAWLgF,EAAKF,OACDnB,EAAW,IAAIqC,GAAkBhB,EAAKF,eAEvCnC,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,iCAWL6E,EAAKC,OACDnB,EAAW,IAAIoC,GAAkBlB,EAAKC,eAEvCnC,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,qCAQDkG,OACAvC,EAAW,IAAIsC,GAAsBC,eAEtCvD,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,YAhE+B0C,0aCErB2D,mIAMV7F,OtBwBJ,SAAmBA,SACF,kBAARA,EsBtBP8F,CAAU9F,KAASO,EAAcP,SAC9BR,KAAK+B,SAAS,4CAVyBP,0aCL9B+E,uFACnBpF,KAAO7C,IAIAsE,aAAe,IAAIyD,KACnBvD,aAAesB,EAAKxB,mFAQnBV,2BAAAA,sBACAyB,IAAe3B,EAAgBE,eAEhCS,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,kEASErE,2BAAAA,qBACW,IAAhBA,EAAKiB,aACD,IAAI0D,MAAM,6CAGX3C,EAAchC,KAAP+F,EAAO/F,iBAEhBoH,cAAgB,CACnBrB,IAAAA,EACA/D,MAAAA,EACAqF,QAAQ,EACRlB,QAAQ,GAGH9B,YA1CgC0C,GCL5B,SAAS8D,GAAkBC,EAAKC,IAClC,MAAPA,GAAeA,EAAMD,EAAI7J,UAAQ8J,EAAMD,EAAI7J,QAE/C,IAAK,IAAID,EAAI,EAAGgK,EAAO,IAAIC,MAAMF,GAAM/J,EAAI+J,EAAK/J,IAC9CgK,EAAKhK,GAAK8J,EAAI9J,GAGhB,OAAOgK,ECHM,SAASE,GAAmBJ,GACzC,OCJa,SAA4BA,GACzC,GAAIG,MAAME,QAAQL,GAAM,OAAOM,GAAiBN,GDGzCO,CAAkBP,IELZ,SAA0BQ,GACvC,GAAsB,oBAAXnJ,QAA0BA,OAAOC,YAAYnD,OAAOqM,GAAO,OAAOL,MAAMM,KAAKD,GFIvDE,CAAgBV,IGJpC,SAAqC/L,EAAG0M,GACrD,GAAK1M,EAAL,CACA,GAAiB,iBAANA,EAAgB,OAAOqM,GAAiBrM,EAAG0M,GACtD,IAAIC,EAAIzM,OAAOS,UAAUC,SAASC,KAAKb,GAAG4M,MAAM,GAAI,GAEpD,MADU,WAAND,GAAkB3M,EAAEgD,cAAa2J,EAAI3M,EAAEgD,YAAY6J,MAC7C,QAANF,GAAqB,QAANA,EAAoBT,MAAMM,KAAKxM,GACxC,cAAN2M,GAAqB,2CAA2CzB,KAAKyB,GAAWN,GAAiBrM,EAAG0M,QAAxG,GHFyDI,CAA2Bf,IILvE,WACb,MAAM,IAAIlK,UAAU,wIJIwEkL,GKoB/E,SAASC,GAAUC,OAC1BC,EAAU,uBACZnF,EAAS,UAEbkF,EAAS1D,SAAQ,gBAAG9C,IAAAA,KAAMjE,IAAAA,IACX,SAATiE,GAAmByG,EAAQhC,KAAK1I,GAEhCuF,GADEA,aACYvF,GAEJA,EAEM,SAATiE,EACTsB,eAAevF,QACG,UAATiE,IACTsB,cAAcvF,WAIXuF,yaCjCYoF,mIAMVrH,MACHM,EAASN,IAAQO,EAAcP,UAC1B,QAGHR,KAAK+B,SAAS,2CAX0BP,0aCG1CrC,GAAmBvE,OAAOS,UAA1B8D,eAEa2I,6CAMPC,uCALZ5G,KAAO7C,EAAKI,SACZqJ,OAAS,OACTC,gBAAiB,IACjBC,gBAAiB,IAIVrF,aAAe,IAAIiF,KACnB/E,aAAesB,EAAKxB,aAIrB9B,EAASiH,GAAS,KACdG,EAAa,GAKnBtN,OAAOwG,KAAK2G,GAAQ9D,SAAQ,SAAC/G,GACvB6K,EAAO7K,aAAgBwF,IACzBwF,EAAWhL,GAAO6K,EAAO7K,SAGxB6K,OAASG,wEASXF,gBAAiB,EACfhI,wDAUFiI,gBAAiB,EACfjI,sCAWAnC,EAAKsK,EAAaR,OAIpB3H,KAAK6C,kBAAoB9B,EAAclD,UACnCmC,KAAKoD,eAAevF,mBAItBwF,UAAUxF,QACVyF,cAAczF,QACd0F,eAAe1F,GAEbmC,KAAKoD,eAAepD,KAAKoI,kBAC9BvK,EACAsK,IAAgBtJ,EAAoB8I,OAAWjI,IAEjD,MAAO6B,QACF8G,kCAAkC9G,OACjCiC,EAAcxD,KAAKyD,eAAelC,EAAMrB,YAE1CsD,QACIA,QAGFjC,6CAaQ1D,cAAK8J,yDAAW,MACZ,OAAhB3H,KAAK+H,cACAlK,MAGH4E,EAAS,GACT6F,EAAQX,EACRvG,EAAOxG,OAAOwG,KAAKpB,KAAK+H,eAE9B3G,EAAK6C,SAAQ,SAAC/G,GACGqL,EAAKR,OAAO7K,GAEf2F,kBAAqB1D,GAAe5D,KAAKsC,EAAKX,GAMxDuF,EAAOvF,GAAOqL,EAAKC,oBAAoB3K,EAAK,CAC1CX,IAAAA,EACAoL,MAAAA,IAPFC,EAAKE,4BAA4B,CAC/BvL,IAAAA,EACAuF,OAAAA,OASDzC,KAAKgI,gBACRpN,OACGwG,KAAKvD,GACLoG,SAAQ,SAAC/G,OACFwL,GAAqC,IAAvBtH,EAAKuH,SAASzL,MAE9BwL,IAAgBH,EAAKN,qBACjB,IAAIhI,qBAA2B/C,uBAGnCwL,IACFjG,EAAOvF,GAAOW,EAAIX,OAInBuF,8CAaW5E,EAAKsC,OACfjD,EAAeiD,EAAfjD,IAAKoL,EAAUnI,EAAVmI,MACPM,EAAS5I,KAAK+H,OAAO7K,GACrB2L,EAAY,CAAE3L,IAAAA,EAAKiE,KAAM,mBAGtByH,EAAOlF,SACZ7F,EAAIX,GACJ2B,eAEKyJ,IACHO,KAGJ,MAAOtH,QACF8G,kCAAkC9G,OACjCuH,aAAkBpB,gBAAcY,IAAOO,kBAEvC,IAAI5I,YACL6I,UAAcvH,EAAMrB,SACvB,CAAEG,OAAO,yDAca0I,OAClB7L,EAAgB6L,EAAhB7L,IAAKuF,EAAWsG,EAAXtG,OAEPmG,EAAS5I,KAAK+H,OAAO7K,GACvB0L,EAAO7F,cAAcC,SACvBP,EAAOvF,GAAO0L,EAAO9E,2BAAsBpE,WAzLPgD,0aCLrBsG,mIAMVxI,OjCoCJ,SAAiBA,SACE,UAAjBD,EAAQC,GiClCRsG,CAAQtG,KAASO,EAAcP,SAC5BR,KAAK+B,SAAS,0CAVuBP,0aCQ5ByH,6CASPC,2CARZ/H,KAAO7C,EAAKK,QACZuK,WAAa,OASNtG,aAAe,IAAIoG,KACnBlG,aAAesB,EAAKxB,aAGrBsG,aAAsBxG,MACnBwG,WAAaA,2CAYlBlE,EAAKF,OACDnB,EAAW,IAAIqC,GAAkBhB,EAAKF,eAEvCnC,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,iCAWL6E,EAAKC,OACDnB,EAAW,IAAIoC,GAAkBlB,EAAKC,eAEvCnC,UAAU5G,KAAK4H,QACfb,aAAea,EACb3D,sCAUArB,EAAOwJ,EAAaR,OAGtB3H,KAAK6C,kBAAoB9B,EAAcpC,UACnCqB,KAAKoD,eAAezE,mBAItB0E,UAAU1E,QACV2E,cAAc3E,QACd4E,eAAe5E,GAEbqB,KAAKoD,eAAepD,KAAKoI,kBAC9BzJ,EACAwJ,IAAgBtJ,EAAoB8I,OAAWjI,IAEjD,MAAO6B,QACF8G,kCAAkC9G,OACjCiC,EAAcxD,KAAKyD,eAAelC,EAAMrB,YAE1CsD,QACIA,QAGFjC,6CAYQ5C,cAAOgJ,yDAAW,GAC5BW,EAAQX,EACNuB,EAAelJ,KAAfkJ,kBAEJA,EACKvK,EAAMwK,KAAI,SAACC,EAAGC,UAAUd,EAAKe,aAAa,CAC/CD,MAAAA,EACA1K,MAAAA,EACA2J,MAAAA,UAKO3J,wCAYAoK,OAETM,EAGEN,EAHFM,MACA1K,EAEEoK,EAFFpK,MACA2J,EACES,EADFT,MAEMY,EAAelJ,KAAfkJ,sBAGCA,EAAWxF,SAChB/E,EAAM0K,GACNxK,eACIyJ,IAAO,CAAEnH,KAAM,QAASjE,IAAKmM,MAEnC,MAAO9H,QACF8G,kCAAkC9G,OACjCsH,EAAY,CAChB1H,KAAM,QACNjE,IAAKmM,GAEDP,aAAkBpB,gBAAcY,IAAOO,kBAEvC,IAAI5I,YACL6I,UAAcvH,EAAMrB,SACvB,CAAEG,OAAO,YAhJwBqC,0aCZpB6G,gFACnBC,QAAU,gCAKKA,2BAAAA,qBAGU,IAAnBA,EAAQ5M,aACJ,IAAIuF,WAAW,gDAGlBqH,QAAUA,+CAQRhJ,WACHiJ,EAAa,KAER9M,EAAI,EAAGA,EAAIqD,KAAKwJ,QAAQ5M,OAAQD,GAAK,aAEnCqD,KAAKwJ,QAAQ7M,GAAG+G,SAASlD,GAChC,MAAOe,GACPkI,EAAalI,QAIXkI,SAhC+B/G,GCIlC,SAAS9D,YACP,IAAIuF,EAGN,SAAS5F,YACP,IAAIgH,GAGN,SAAS/G,YACP,IAAI4H,GAGN,SAAS3H,YACP,IAAI8H,GAGN,SAAS7H,GAAOqJ,UACd,IAAID,GAAaC,GAGnB,SAASpJ,GAAMuK,UACb,IAAID,GAAYC,GAGlB,SAASQ,gCAASF,2BAAAA,2BACZD,GAAeC,UAGb,CACb5K,IAAAA,GACAL,OAAAA,GACAC,OAAAA,GACAC,QAAAA,GACAC,OAAAA,GACAC,MAAAA,GACA+K,MAAAA"}