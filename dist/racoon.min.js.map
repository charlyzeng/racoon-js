{"version":3,"sources":["webpack://racoon/webpack/universalModuleDefinition","webpack://racoon/webpack/bootstrap","webpack://racoon/./node_modules/@babel/runtime/helpers/interopRequireDefault.js","webpack://racoon/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://racoon/./node_modules/@babel/runtime/helpers/createClass.js","webpack://racoon/./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack://racoon/./node_modules/@babel/runtime/helpers/inherits.js","webpack://racoon/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack://racoon/./lib/util/is.js","webpack://racoon/./lib/restrict/base.js","webpack://racoon/./lib/schema/base.js","webpack://racoon/./node_modules/@babel/runtime/helpers/construct.js","webpack://racoon/./lib/util/constants.js","webpack://racoon/./lib/util/validate-error.js","webpack://racoon/./lib/restrict/enum.js","webpack://racoon/./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack://racoon/./node_modules/@babel/runtime/helpers/get.js","webpack://racoon/./lib/restrict/length-max.js","webpack://racoon/./lib/restrict/length-min.js","webpack://racoon/./node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack://racoon/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack://racoon/./lib/util/get-key-str.js","webpack://racoon/./lib/index.js","webpack://racoon/./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js","webpack://racoon/./lib/schema/any.js","webpack://racoon/./node_modules/@babel/runtime/helpers/typeof.js","webpack://racoon/./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack://racoon/./lib/restrict/any-schema.js","webpack://racoon/./node_modules/@babel/runtime/helpers/superPropBase.js","webpack://racoon/./node_modules/@babel/runtime/helpers/wrapNativeSuper.js","webpack://racoon/./node_modules/@babel/runtime/helpers/isNativeFunction.js","webpack://racoon/./lib/restrict/any-required.js","webpack://racoon/./lib/restrict/required.js","webpack://racoon/./lib/restrict/custom.js","webpack://racoon/./lib/schema/number.js","webpack://racoon/./lib/restrict/number-schema.js","webpack://racoon/./lib/restrict/number-required.js","webpack://racoon/./lib/restrict/number-max.js","webpack://racoon/./lib/restrict/number-min.js","webpack://racoon/./lib/restrict/number-int.js","webpack://racoon/./lib/restrict/number-even.js","webpack://racoon/./lib/restrict/number-odd.js","webpack://racoon/./lib/schema/string.js","webpack://racoon/./lib/restrict/string-schema.js","webpack://racoon/./lib/restrict/string-pattern.js","webpack://racoon/./lib/schema/boolean.js","webpack://racoon/./lib/restrict/boolean-schema.js","webpack://racoon/./lib/schema/object.js","webpack://racoon/./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack://racoon/./node_modules/@babel/runtime/helpers/iterableToArray.js","webpack://racoon/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack://racoon/./node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack://racoon/./lib/restrict/object-schema.js","webpack://racoon/./lib/schema/arrary.js","webpack://racoon/./lib/restrict/array-schema.js","webpack://racoon/./lib/schema/mixed.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","obj","instance","Constructor","TypeError","_defineProperties","target","props","length","descriptor","configurable","writable","protoProps","staticProps","_getPrototypeOf","setPrototypeOf","getPrototypeOf","__proto__","subClass","superClass","constructor","_typeof","assertThisInitialized","self","val","isNumber","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","RegExp","getType","type","keys","isNotRequired","isNaN","test","error","ValidateError","custom","final","toString","str","substring","isUndefined","undefined","isNull","RestrictBase","errorConfig","ctx","message","originMessage","isFunction","isString","SchemaBase","restricts","typeRestrict","requiredRestrict","lastRestrict","defaultConfig","enable","strict","formatterConfig","formatter","errorForAllConfig","getReturnValue","checkType","checkRequired","checkRestricts","isCustomError","errorForAll","getErrorForAll","validate","RestrictRequired","restrictFn","restrict","RestrictCustom","push","ensureMessageType","setErrorMessage","args","Error","isEmpty","getDefaultReturnValue","getReturnValueWithoutStrict","originalMessage","forEach","isFinalError","isNativeReflectConstruct","_construct","Parent","Class","Reflect","construct","a","apply","Function","arguments","number","string","boolean","array","any","useKeyChainSymbol","options","RestrictEnum","enumValues","values","RangeError","indexOf","getError","JSON","stringify","_setPrototypeOf","superPropBase","_get","receiver","base","desc","getOwnPropertyDescriptor","RestrictLengthMax","max","closed","RestrictLengthMin","min","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","arr","len","arr2","Array","keyChain","propReg","result","SchemaAny","SchemaNumber","SchemaString","SchemaBoolean","config","SchemaObject","itemSchema","SchemaArray","mixed","schemas","SchemaMixed","sham","Proxy","Date","e","TYPE","RestrictAnySchema","RestrictAnyRequired","iterator","ReferenceError","isNativeFunction","_wrapNativeSuper","_cache","Map","has","set","Wrapper","fn","isAllowString","RestrictNumberSchema","RestrictNumberRequired","enableAllowNaN","enableAllowInfinity","RestrictNumberMin","RestrictNumberMax","RestrictNumberInt","RestrictNumberEven","RestrictNumberOdd","isStringNumber","isAllowNaN","isAllowInfinity","isInfinity","isInt","Math","abs","RestrictStringSchema","pattern","RestrictStringPattern","isRegExp","RestrictBooleanSchema","isBoolean","isStripUnknown","isAllowUnknown","RestrictObjectSchema","isObject","pureConfig","useKeyChain","validateByRecurse","throwErrorWithoutKeyChainIfNeeded","chain","validateObjectByKey","setResultWhenDefaultEnabled","notIncluded","includes","schema","keyOption","keyChainStr","params","arrayLikeToArray","isArray","iter","from","minLen","slice","RestrictArraySchema","map","_","index","validateItem","finalError"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAgB,OAAID,IAEpBD,EAAa,OAAIC,IARnB,CASGK,MAAM,WACT,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,I,gBC5ErDtC,EAAOD,QANP,SAAgCwC,GAC9B,OAAOA,GAAOA,EAAIZ,WAAaY,EAAM,CACnC,QAAWA,K,cCIfvC,EAAOD,QANP,SAAyByC,EAAUC,GACjC,KAAMD,aAAoBC,GACxB,MAAM,IAAIC,UAAU,uC,cCFxB,SAASC,EAAkBC,EAAQC,GACjC,IAAK,IAAItC,EAAI,EAAGA,EAAIsC,EAAMC,OAAQvC,IAAK,CACrC,IAAIwC,EAAaF,EAAMtC,GACvBwC,EAAW5B,WAAa4B,EAAW5B,aAAc,EACjD4B,EAAWC,cAAe,EACtB,UAAWD,IAAYA,EAAWE,UAAW,GACjDhC,OAAOC,eAAe0B,EAAQG,EAAWjB,IAAKiB,IAUlD/C,EAAOD,QANP,SAAsB0C,EAAaS,EAAYC,GAG7C,OAFID,GAAYP,EAAkBF,EAAYN,UAAWe,GACrDC,GAAaR,EAAkBF,EAAaU,GACzCV,I,cCbT,SAASW,EAAgBpC,GAIvB,OAHAhB,EAAOD,QAAUqD,EAAkBnC,OAAOoC,eAAiBpC,OAAOqC,eAAiB,SAAyBtC,GAC1G,OAAOA,EAAEuC,WAAatC,OAAOqC,eAAetC,IAEvCoC,EAAgBpC,GAGzBhB,EAAOD,QAAUqD,G,gBCPjB,IAAIC,EAAiB,EAAQ,IAiB7BrD,EAAOD,QAfP,SAAmByD,EAAUC,GAC3B,GAA0B,mBAAfA,GAA4C,OAAfA,EACtC,MAAM,IAAIf,UAAU,sDAGtBc,EAASrB,UAAYlB,OAAOY,OAAO4B,GAAcA,EAAWtB,UAAW,CACrEuB,YAAa,CACXlC,MAAOgC,EACPP,UAAU,EACVD,cAAc,KAGdS,GAAYJ,EAAeG,EAAUC,K,gBCd3C,IAAIE,EAAU,EAAQ,IAElBC,EAAwB,EAAQ,IAUpC5D,EAAOD,QARP,SAAoC8D,EAAMnD,GACxC,OAAIA,GAA2B,WAAlBiD,EAAQjD,IAAsC,mBAATA,EAI3CkD,EAAsBC,GAHpBnD,I,mSCeJ,SAAkBoD,GACvB,MAAsB,iBAARA,G,qBAOT,SAAeA,GACpB,OAAOC,EAASD,IAAQA,EAAM,GAAM,G,aAG/B,SAAoBA,GACzB,OACEA,IAAQE,OAAOC,mBACZH,IAAQE,OAAOE,mB,YAIf,SAAmBJ,GACxB,MAAsB,kBAARA,G,WAGT,SAAkBA,GACvB,OAAOA,aAAeK,Q,WAGjB,SAAkBL,GACvB,MAAwB,WAAjBM,EAAQN,I,UAGV,SAAiBA,GACtB,MAAwB,UAAjBM,EAAQN,I,4BAOV,SAAiBA,GACtB,IAAMO,EAAOD,EAAQN,GAErB,MAAa,WAATO,EACiC,IAA5BpD,OAAOqD,KAAKR,GAAKhB,OAGb,UAATuB,EACoB,IAAfP,EAAIhB,OAIXyB,EAAcT,IACXU,EAAMV,IACE,KAARA,G,aAUA,SAAoBA,GACzB,MAAwB,aAAjBM,EAAQN,I,iBAcV,SAAwBA,GAC7B,OAAI,QAAQW,KAAKX,KAGTU,EAAMR,OAAOF,K,gBAQhB,SAAuBY,GAC5B,OAAOA,aAAiBC,WAAiBD,EAAME,Q,eAQ1C,SAAsBF,GAC3B,OAAOA,aAAiBC,WAAiBD,EAAMG,O,WAvHzCC,EAAa7D,OAAOkB,UAApB2C,SAED,SAASV,EAAQN,GACtB,IAAMiB,EAAMD,EAASpE,KAAKoD,GAC1B,OAAOiB,EAAIC,UAAU,EAAGD,EAAIjC,OAAS,GAGhC,SAASmC,EAAYnB,GAC1B,YAAeoB,IAARpB,EAGF,SAASqB,EAAOrB,GACrB,OAAe,OAARA,EAGF,SAASU,EAAMV,GACpB,OAAOA,GAAQA,EAOV,SAASC,EAASD,GACvB,MAAsB,iBAARA,EA8BT,SAASS,EAAcT,GAC5B,OAAOmB,EAAYnB,IAAQqB,EAAOrB,M,sUClDfsB,E,mDAInBC,YAAc,CACZC,IAAK,KACLC,QAAS,I,6DASKA,EAASD,GACvBnF,KAAKkF,YAAc,CACjBC,MACAC,a,+BAUKC,GAAe,MACGrF,KAAKkF,YAAtBE,EADc,EACdA,QAASD,EADK,EACLA,IAEjB,OAAI,IAAAG,YAAWF,GACN,IAAIZ,UACTY,EAAQ7E,KAAK4E,EAAKE,GAClB,CAAEZ,QAAQ,IAIVW,IAAW,IAAAG,UAASH,GACf,IAAIZ,UACTY,EACA,CAAEX,QAAQ,IAIP,IAAID,UAAca,O,uXCnCRG,E,mDACnBC,UAAY,G,KACZC,aAAe,K,KACfC,iBAAmB,K,KAInBC,aAAe,K,KAGfC,cAAgB,CACdC,QAAQ,EACRC,QAAQ,EACRZ,IAAK,KACL9D,WAAO0D,G,KAKTiB,gBAAkB,CAChBb,SAAKJ,EACLkB,UAAW,SAAAtC,GAAG,OAAIA,I,KAKpBuC,kBAAoB,CAClBJ,QAAQ,EACRX,SAAKJ,EACLK,QAAS,I,sDAQFzB,GAGP,IAAK3D,KAAK2F,mBAAoB,IAAAvB,eAAcT,GAC1C,OAAO3D,KAAKmG,eAAexC,GAG7B,IAKE,OAJA3D,KAAKoG,UAAUzC,GACf3D,KAAKqG,cAAc1C,GACnB3D,KAAKsG,eAAe3C,GAEb3D,KAAKmG,eAAexC,GAC3B,MAAOY,GACP,IAAI,IAAAgC,eAAchC,GAChB,MAAMA,EAGR,IAAMiC,EAAcxG,KAAKyG,eAAelC,EAAMa,SAE9C,GAAIoB,EACF,MAAMA,EAGR,MAAMjC,K,qCAUKZ,GACb,IACE,MAAO,CACLtC,MAAOrB,KAAK0G,SAAS/C,IAEvB,MAAOY,GACP,MAAO,CACLA,QACAlD,MAAOsC,M,+BAWJoC,GAGP,OAFA/F,KAAK2F,iBAAmB,IAAIgB,UAAiBZ,GAC7C/F,KAAK4F,aAAe5F,KAAK2F,iBAClB3F,O,6BASF4G,EAAYzB,GACjB,IAAM0B,EAAW,IAAIC,UAAeF,EAAYzB,GAIhD,OAFAnF,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,4BASHoF,EAASD,GAGb,OAFAnF,KAAKgH,kBAAkB5B,GACvBpF,KAAK4F,aAAaqB,gBAAgB7B,EAASD,GACpCnF,O,kCAUGoF,EAASD,GAQnB,OAPAnF,KAAKgH,kBAAkB5B,GACvBpF,KAAKkG,kBAAoB,CACvBJ,QAAQ,EACRV,UACAD,OAGKnF,O,gCAUQ,2BAANkH,EAAM,yBAANA,EAAM,gBACf,GAAoB,IAAhBA,EAAKvE,OACP,MAAM,IAAIwE,MAAM,yCAFH,IAKR9F,EAAsB6F,EALd,GAKDnB,EAAemB,EALd,GAKO/B,EAAO+B,EALd,GAaf,OAPAlH,KAAK6F,cAAgB,CACnBV,MACA9D,QACAyE,QAAQ,EACRC,QAAmB,IAAXA,GAGH/F,O,6BASFiG,EAAWd,GAChB,GAAyB,mBAAdc,EACT,MAAM,IAAI1D,UAAU,4CAQtB,OALAvC,KAAKgG,gBAAkB,CACrBb,MACAc,aAGKjG,O,qCAQM2D,GAAK,MACS3D,KAAK6F,cAAxBC,EADU,EACVA,OAAQC,EADE,EACFA,OADE,EAES/F,KAAKgG,gBAAxBC,EAFU,EAEVA,UAAWd,EAFD,EAECA,IAEnB,OAAIW,GAAUC,IAAU,IAAAqB,SAAQzD,GACvBsC,EAAU1F,KACf4E,EACAnF,KAAKqH,sBAAsB1D,IAIxB3D,KAAKsH,4BAA4B3D,K,4CAQpBA,GAAK,MACF3D,KAAK6F,cAApBxE,EADiB,EACjBA,MAAO8D,EADU,EACVA,IAEf,MAAqB,mBAAV9D,EACFA,EAAMd,KAAK4E,EAAKxB,GAGlBtC,I,qCAQMkG,GAAiB,MAK1BvH,KAAKkG,kBAHPf,EAF4B,EAE5BA,IACAW,EAH4B,EAG5BA,OACAV,EAJ4B,EAI5BA,QAGF,OAAe,IAAXU,EACK,MAGL,IAAAR,YAAWF,GACN,IAAIZ,UAAcY,EAAQ7E,KAAK4E,EAAKoC,IAGtC,IAAI/C,UAAcY,K,gCAQjBzB,GACR,OAAO3D,KAAK0F,aAAagB,SAAS/C,K,oCAQtBA,GACZ,OAAK3D,KAAK2F,kBAIH3F,KAAK2F,iBAAiBe,SAAS/C,K,qCAQzBA,GAIb,OAHA3D,KAAKyF,UAAU+B,SAAQ,SAACX,GACtBA,EAASH,SAAS/C,OAEb,I,wDAUyBY,GAChC,IAAI,IAAAkD,cAAalD,GACf,MAAMA,EAGR,IAAI,IAAAgC,eAAchC,GAChB,MAAM,IAAIC,UAAcD,EAAMa,QAAS,CAAEV,OAAO,M,wCAUlCU,GAChB,KAAK,IAAAG,UAASH,MAAa,IAAAE,YAAWF,GACpC,MAAM,IAAI7C,UAAU,sD,kDAUIoB,GAAK,IACvBmC,EAAW9F,KAAK6F,cAAhBC,OADuB,EAEJ9F,KAAKgG,gBAAxBC,EAFuB,EAEvBA,UAAWd,EAFY,EAEZA,IACf9D,EAAQsC,EASZ,OALImC,KAAW,IAAA1B,eAAcT,KAAQ,IAAAU,OAAMV,MACzCtC,EAAQrB,KAAKqH,sBAAsB1D,IAI9BsC,EAAU1F,KAAK4E,EAAK9D,O,mECjV/B,IAAI6B,EAAiB,EAAQ,IAEzBwE,EAA2B,EAAQ,IAEvC,SAASC,EAAWC,EAAQV,EAAMW,GAchC,OAbIH,IACF7H,EAAOD,QAAU+H,EAAaG,QAAQC,UAEtClI,EAAOD,QAAU+H,EAAa,SAAoBC,EAAQV,EAAMW,GAC9D,IAAIG,EAAI,CAAC,MACTA,EAAEjB,KAAKkB,MAAMD,EAAGd,GAChB,IACI7E,EAAW,IADG6F,SAAStG,KAAKqG,MAAML,EAAQI,IAG9C,OADIH,GAAO3E,EAAeb,EAAUwF,EAAM7F,WACnCK,GAIJsF,EAAWM,MAAM,KAAME,WAGhCtI,EAAOD,QAAU+H,G,6PCrBG,CAClBS,OAAQ,SACRC,OAAQ,SACRC,QAAS,UACTxG,OAAQ,SACRyG,MAAO,QACPC,IAAK,OAGA,IAAMC,EAAoBtH,OAAO,sB,80BCTnBqD,E,0CAInB,WAAYY,GAAuB,MAAdsD,EAAc,uDAAJ,IAAI,sBACjC,cAAMtD,IAJRX,QAAS,EAG0B,EAFnCC,OAAQ,EAE2B,MAK7BgE,EAFFjE,cAH+B,WAK7BiE,EADFhE,aAJ+B,gBAOjC,EAAKD,OAASA,EACd,EAAKC,MAAQA,EARoB,E,wDAYjC,kG,wBAhBuCyC,Q,ozBCMtBwB,E,0CAMnB,aAAuB,6BACrB,gBANFC,WAAa,KAKU,2BAARC,EAAQ,yBAARA,EAAQ,gBAGrB,GAAsB,IAAlBA,EAAOlG,OACT,MAAM,IAAImG,WAAW,sCAJF,OAOrB,EAAKF,WAAaC,EAPG,E,sDAedlF,GACP,IAAsC,IAAlC3D,KAAK4I,WAAWG,QAAQpF,GAC1B,MAAM3D,KAAKgJ,SAAL,iCAAwCC,KAAKC,UAAUlJ,KAAK4I,kB,YAvB9B3D,S,4DCN1C,SAASkE,EAAgBtI,EAAGqB,GAM1B,OALArC,EAAOD,QAAUuJ,EAAkBrI,OAAOoC,gBAAkB,SAAyBrC,EAAGqB,GAEtF,OADArB,EAAEuC,UAAYlB,EACPrB,GAGFsI,EAAgBtI,EAAGqB,GAG5BrC,EAAOD,QAAUuJ,G,gBCTjB,IAAIC,EAAgB,EAAQ,IAE5B,SAASC,EAAK5G,EAAQV,EAAUuH,GAiB9B,MAhBuB,oBAAZxB,SAA2BA,QAAQ7G,IAC5CpB,EAAOD,QAAUyJ,EAAOvB,QAAQ7G,IAEhCpB,EAAOD,QAAUyJ,EAAO,SAAc5G,EAAQV,EAAUuH,GACtD,IAAIC,EAAOH,EAAc3G,EAAQV,GACjC,GAAKwH,EAAL,CACA,IAAIC,EAAO1I,OAAO2I,yBAAyBF,EAAMxH,GAEjD,OAAIyH,EAAKvI,IACAuI,EAAKvI,IAAIV,KAAK+I,GAGhBE,EAAKnI,QAITgI,EAAK5G,EAAQV,EAAUuH,GAAY7G,GAG5C5C,EAAOD,QAAUyJ,G,6wBCdIK,E,0CAOnB,WAAYC,EAAKC,GAAQ,MAGvB,IAHuB,qBACvB,gBAEsB,KAAlB,IAAAhG,UAAS+F,GACX,MAAM,IAAIpH,UAAU,oCAJC,OAOvB,EAAKoH,IAAMA,EACX,EAAKC,QAAoB,IAAXA,EARS,E,sDAgBhBjG,GACP,GAAI3D,KAAK4J,QAAUjG,EAAIhB,OAAS3C,KAAK2J,IACnC,MAAM3J,KAAKgJ,SAAL,uDAA8DhJ,KAAK2J,MAG3E,IAAK3J,KAAK4J,QAAUjG,EAAIhB,QAAU3C,KAAK2J,IACrC,MAAM3J,KAAKgJ,SAAL,2CAAkDhJ,KAAK2J,MAG/D,OAAO,M,YAhCoC1E,S,2zBCA1B4E,E,0CAOnB,WAAYC,EAAKF,GAAQ,MAGvB,IAHuB,qBACvB,gBAEsB,KAAlB,IAAAhG,UAASkG,GACX,MAAM,IAAIvH,UAAU,oCAJC,OAOvB,EAAKuH,IAAMA,EACX,EAAKF,QAAoB,IAAXA,EARS,E,sDAgBhBjG,GACP,GAAI3D,KAAK4J,QAAUjG,EAAIhB,OAAS3C,KAAK8J,IACnC,MAAM9J,KAAKgJ,SAAL,0DAAiEhJ,KAAK8J,MAG9E,IAAK9J,KAAK4J,QAAUjG,EAAIhB,QAAU3C,KAAK8J,IACrC,MAAM9J,KAAKgJ,SAAL,2CAAkDhJ,KAAK8J,MAG/D,OAAO,M,YAhCoC7E,S,8DCR/C,IAAI8E,EAAoB,EAAQ,IAE5BC,EAAkB,EAAQ,IAE1BC,EAA6B,EAAQ,IAErCC,EAAoB,EAAQ,IAMhCrK,EAAOD,QAJP,SAA4BuK,GAC1B,OAAOJ,EAAkBI,IAAQH,EAAgBG,IAAQF,EAA2BE,IAAQD,M,cCC9FrK,EAAOD,QAVP,SAA2BuK,EAAKC,IACnB,MAAPA,GAAeA,EAAMD,EAAIxH,UAAQyH,EAAMD,EAAIxH,QAE/C,IAAK,IAAIvC,EAAI,EAAGiK,EAAO,IAAIC,MAAMF,GAAMhK,EAAIgK,EAAKhK,IAC9CiK,EAAKjK,GAAK+J,EAAI/J,GAGhB,OAAOiK,I,8NCkBM,SAAmBE,GAChC,IAAMC,EAAU,uBACZC,EAAS,GAgBb,OAdAF,EAAS/C,SAAQ,YAAmB,IAAhBtD,EAAgB,EAAhBA,KAAMvC,EAAU,EAAVA,IACX,SAATuC,GAAmBsG,EAAQlG,KAAK3C,GAEhC8I,GADEA,EACQ,IAAJ,OAAQ9I,GAEJA,EAEM,SAATuC,EACTuG,GAAU,KAAJ,OAAS9I,EAAT,MACY,UAATuC,IACTuG,GAAU,IAAJ,OAAQ9I,EAAR,SAIH8I,K,6NCjCF,SAASjC,IACd,OAAO,IAAIkC,YAGN,SAAStC,IACd,OAAO,IAAIuC,eAGN,SAAStC,IACd,OAAO,IAAIuC,eAGN,SAAStC,IACd,OAAO,IAAIuC,gBAGN,SAAS/I,EAAOgJ,GACrB,OAAO,IAAIC,eAAaD,GAGnB,SAASvC,EAAMyC,GACpB,OAAO,IAAIC,cAAYD,GAGlB,SAASE,IAAkB,2BAATC,EAAS,yBAATA,EAAS,gBAChC,oBAAWC,cAAeD,G,wJAGb,CACb3C,MACAJ,SACAC,SACAC,UACAxG,SACAyG,QACA2C,S,4DChCFrL,EAAOD,QAbP,WACE,GAAuB,oBAAZkI,UAA4BA,QAAQC,UAAW,OAAO,EACjE,GAAID,QAAQC,UAAUsD,KAAM,OAAO,EACnC,GAAqB,mBAAVC,MAAsB,OAAO,EAExC,IAEE,OADAC,KAAKvJ,UAAU2C,SAASpE,KAAKuH,QAAQC,UAAUwD,KAAM,IAAI,iBAClD,EACP,MAAOC,GACP,OAAO,K,8xDCCUd,E,0CAGnB,aAAc,mCACZ,gBAHFxG,KAAOuH,OAAKjD,IAIV,EAAK9C,aAAe,IAAIgG,UACxB,EAAK9F,aAAe,EAAKF,aAHb,E,sDAYLK,GAGP,OAFA/F,KAAK2F,iBAAmB,IAAIgG,UAAoB5F,GAChD/F,KAAK4F,aAAe5F,KAAK2F,iBAClB3F,O,6BAQO,2BAAR6I,EAAQ,yBAARA,EAAQ,gBACd,IAAMhC,GAAW,EAAH,WAAO8B,UAAgBE,GAIrC,OAFA7I,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,S,YA/B4BwF,S,4DCVvC,SAAShC,EAAQpB,GAaf,MAVsB,mBAAXjB,QAAoD,iBAApBA,OAAOyK,SAChD/L,EAAOD,QAAU4D,EAAU,SAAiBpB,GAC1C,cAAcA,GAGhBvC,EAAOD,QAAU4D,EAAU,SAAiBpB,GAC1C,OAAOA,GAAyB,mBAAXjB,QAAyBiB,EAAImB,cAAgBpC,QAAUiB,IAAQjB,OAAOa,UAAY,gBAAkBI,GAItHoB,EAAQpB,GAGjBvC,EAAOD,QAAU4D,G,cCRjB3D,EAAOD,QARP,SAAgC8D,GAC9B,QAAa,IAATA,EACF,MAAM,IAAImI,eAAe,6DAG3B,OAAOnI,I,swBCGYgI,E,mKAOjB,OAAO,M,YAPoCzG,S,8DCR/C,IAAI9B,EAAiB,EAAQ,GAW7BtD,EAAOD,QATP,SAAwBkC,EAAQC,GAC9B,MAAQjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAEpC,QADfD,EAASqB,EAAerB,MAI1B,OAAOA,I,gBCRT,IAAIqB,EAAiB,EAAQ,GAEzBD,EAAiB,EAAQ,IAEzB4I,EAAmB,EAAQ,IAE3B/D,EAAY,EAAQ,GAExB,SAASgE,EAAiBlE,GACxB,IAAImE,EAAwB,mBAARC,IAAqB,IAAIA,SAAQlH,EA8BrD,OA5BAlF,EAAOD,QAAUmM,EAAmB,SAA0BlE,GAC5D,GAAc,OAAVA,IAAmBiE,EAAiBjE,GAAQ,OAAOA,EAEvD,GAAqB,mBAAVA,EACT,MAAM,IAAItF,UAAU,sDAGtB,QAAsB,IAAXyJ,EAAwB,CACjC,GAAIA,EAAOE,IAAIrE,GAAQ,OAAOmE,EAAO/K,IAAI4G,GAEzCmE,EAAOG,IAAItE,EAAOuE,GAGpB,SAASA,IACP,OAAOrE,EAAUF,EAAOM,UAAWhF,EAAenD,MAAMuD,aAW1D,OARA6I,EAAQpK,UAAYlB,OAAOY,OAAOmG,EAAM7F,UAAW,CACjDuB,YAAa,CACXlC,MAAO+K,EACPpL,YAAY,EACZ8B,UAAU,EACVD,cAAc,KAGXK,EAAekJ,EAASvE,IAG1BkE,EAAiBlE,GAG1BhI,EAAOD,QAAUmM,G,cCtCjBlM,EAAOD,QAJP,SAA2ByM,GACzB,OAAgE,IAAzDnE,SAASvD,SAASpE,KAAK8L,GAAItD,QAAQ,mB,6wBCavB4C,E,0CAQnB,WAAY5F,GAAQ,mCAClB,gBARFA,QAAS,EASP,EAAKA,QAAoB,IAAXA,EAFI,E,sDAUXpC,GAAK,IACJoC,EAAW/F,KAAX+F,OAIR,IAAKA,KAAW,IAAA3B,eAAcT,KAAQ,IAAAU,OAAMV,IAC1C,MAAM3D,KAAKgJ,SAAS,0DAGtB,IAAe,IAAXjD,IAAmB,IAAAqB,SAAQzD,GAC7B,MAAM3D,KAAKgJ,SAAS,iD,YA5BuB/D,S,2zBCL5B0B,E,0CAOnB,WAAYZ,GAAQ,mCAClB,gBAPFA,QAAS,EAQP,EAAKA,QAAoB,IAAXA,EAFI,E,sDAUXpC,GAAK,IACJoC,EAAW/F,KAAX+F,OAER,GAAIA,IAAU,IAAAqB,SAAQzD,GACpB,MAAM3D,KAAKgJ,SAAS,6CAGtB,IAAKjD,IAAU,IAAA3B,eAAcT,GAC3B,MAAM3D,KAAKgJ,SAAS,0D,YAzBoB/D,S,2zBCFzB6B,E,0CAYnB,WAAYF,EAAYzB,GAAK,MAG3B,IAH2B,sBAC3B,gBAZFA,IAAM,KAWuB,EAV7ByB,WAAa,MAaoB,KAA3B,IAAAtB,YAAWsB,GACb,MAAM,IAAIrE,UAAU,6CAJK,OAO3B,EAAKqE,WAAaA,EAClB,EAAKzB,IAAMA,EARgB,E,sDAgBpBxB,GACP,IACE,IAAM8G,EAASzK,KAAK4G,WAAWrG,KAAKP,KAAKmF,IAAKxB,GAG9C,IAAI,IAAA4B,UAASkF,IAAWA,EACtB,MAAMzK,KAAKgJ,SAASyB,GAEtB,MAAOlG,GAGP,MAAMvE,KAAKgJ,SAASzE,EAAMa,SAG5B,OAAO,M,YA1CiCH,S,w9BCQvB0F,E,0CAInB,aAAc,mCACZ,gBAJFzG,KAAOuH,OAAKrD,OAGE,EAFdkE,eAAgB,EAId,EAAK5G,aAAe,IAAI6G,UACxB,EAAK3G,aAAe,EAAKF,aAHb,E,uDAYG,2BAANwB,EAAM,yBAANA,EAAM,gBACf,GAAoB,IAAhBA,EAAKvE,OACP,MAAM,IAAIwE,MAAM,yCAFH,IAKR9F,EAAc6F,EALN,GAKD/B,EAAO+B,EALN,GAcf,OAPAlH,KAAK6F,cAAgB,CACnBV,MACA9D,QACAyE,QAAQ,EACRC,QAAQ,GAGH/F,O,6BAQO,2BAAR6I,EAAQ,yBAARA,EAAQ,gBACd,IAAMhC,GAAW,EAAH,WAAO8B,UAAgBE,GAIrC,OAFA7I,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,iCASP,OAFAA,KAAK2F,iBAAmB,IAAI6G,UAC5BxM,KAAK4F,aAAe5F,KAAK2F,iBAClB3F,O,iCASP,OADAA,KAAK0F,aAAa+G,iBACXzM,O,sCASP,OADAA,KAAK0F,aAAagH,sBACX1M,O,oCAUP,OADAA,KAAKsM,eAAgB,EACdtM,O,0BAWL8J,EAAKF,GACP,IAAM/C,EAAW,IAAI8F,UAAkB7C,EAAKF,GAI5C,OAFA5J,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,0BAWL2J,EAAKC,GACP,IAAM/C,EAAW,IAAI+F,UAAkBjD,EAAKC,GAI5C,OAFA5J,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,4BAOP,IAAM6G,EAAW,IAAIgG,UAIrB,OAFA7M,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,6BAIP,IAAM6G,EAAW,IAAIiG,UAIrB,OAFA9M,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,4BAIP,IAAM6G,EAAW,IAAIkG,UAIrB,OAFA/M,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,+BASA2D,GACP,IAAItC,EAAQsC,EAWZ,OAPE3D,KAAKsM,gBACF,IAAA/G,UAAS5B,KACT,IAAAqJ,gBAAerJ,KAElBtC,EAAQwC,OAAOF,KAGjB,mEAAsBtC,O,YAhKgBmE,S,2zBCHrB+G,E,sMAEnBU,YAAa,E,EAGbC,iBAAkB,E,gEAMhBlN,KAAKiN,YAAa,I,4CAOlBjN,KAAKkN,iBAAkB,I,+BAQhBvJ,GAAK,IACJsJ,EAAgCjN,KAAhCiN,WAAYC,EAAoBlN,KAApBkN,gBAEpB,IAAI,IAAA7I,OAAMV,KAASsJ,EACjB,MAAMjN,KAAKgJ,SAAS,kCAGtB,IAAI,IAAAmE,YAAWxJ,KAASuJ,EACtB,MAAMlN,KAAKgJ,SAAS,uCAGtB,KAAK,IAAApF,UAASD,MAAS,IAAAS,eAAcT,GACnC,MAAM3D,KAAKgJ,SAAS,wC,YAtCwB/D,S,2zBCH7B0B,E,iKAMVhD,GACP,IAAI,IAAAS,eAAcT,GAChB,MAAM3D,KAAKgJ,SAAS,sDAKtB,IAAI,IAAA3E,OAAMV,GACR,MAAM3D,KAAKgJ,SAAS,+C,YAdoB/D,S,2zBCFzB2H,E,0CAOnB,WAAYjD,EAAKC,GAAQ,MAGvB,IAHuB,qBACvB,gBAEsB,KAAlB,IAAAhG,UAAS+F,GACX,MAAM,IAAIpH,UAAU,oCAJC,OAOvB,EAAKoH,IAAMA,EACX,EAAKC,QAAoB,IAAXA,EARS,E,sDAgBhBjG,GACP,GAAI3D,KAAK4J,QAAUjG,EAAM3D,KAAK2J,IAC5B,MAAM3J,KAAKgJ,SAAL,gDAAuDhJ,KAAK2J,MAGpE,IAAK3J,KAAK4J,QAAUjG,GAAO3D,KAAK2J,IAC9B,MAAM3J,KAAKgJ,SAAL,oCAA2ChJ,KAAK2J,U,YA7Bb1E,S,2zBCA1B0H,E,0CAOnB,WAAY7C,EAAKF,GAAQ,MAGvB,IAHuB,qBACvB,gBAEsB,KAAlB,IAAAhG,UAASkG,GACX,MAAM,IAAIvH,UAAU,oCAJC,OAOvB,EAAKuH,IAAMA,EACX,EAAKF,QAAoB,IAAXA,EARS,E,sDAgBhBjG,GACP,GAAI3D,KAAK4J,QAAUjG,EAAM3D,KAAK8J,IAC5B,MAAM9J,KAAKgJ,SAAL,mDAA0DhJ,KAAK8J,MAGvE,IAAK9J,KAAK4J,QAAUjG,GAAO3D,KAAK8J,IAC9B,MAAM9J,KAAKgJ,SAAL,uCAA8ChJ,KAAK8J,U,YA7BhB7E,S,2zBCC1B4H,E,iKAMVlJ,GACP,IAAmB,KAAf,IAAAyJ,OAAMzJ,GACR,MAAM3D,KAAKgJ,SAAS,kC,YARqB/D,S,ozBCF1B6H,E,iKAMVnJ,GACP,GAAIA,EAAM,GAAM,EACd,MAAM3D,KAAKgJ,SAAS,uC,YARsB/D,S,ozBCA3B8H,E,iKAMVpJ,GACP,GAAI0J,KAAKC,IAAI3J,GAAO,GAAM,EACxB,MAAM3D,KAAKgJ,SAAS,sC,YARqB/D,S,q5BCE1B2F,E,0CAGnB,aAAc,mCACZ,gBAHF1G,KAAOuH,OAAKpD,OAIV,EAAK3C,aAAe,IAAI6H,UACxB,EAAK3H,aAAe,EAAKF,aAHb,E,oDAWE,2BAARmD,EAAQ,yBAARA,EAAQ,gBACd,IAAMhC,GAAW,EAAH,WAAO8B,UAAgBE,GAIrC,OAFA7I,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,0BAWL8J,EAAKF,GACP,IAAM/C,EAAW,IAAIgD,UAAkBC,EAAKF,GAI5C,OAFA5J,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,0BAWL2J,EAAKC,GACP,IAAM/C,EAAW,IAAI6C,UAAkBC,EAAKC,GAI5C,OAFA5J,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,8BAQDwN,GACN,IAAM3G,EAAW,IAAI4G,UAAsBD,GAI3C,OAFAxN,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,S,YAhE+BwF,S,2zBCErB+H,E,iKAMV5J,GACP,KAAK,IAAA4B,UAAS5B,MAAS,IAAAS,eAAcT,GACnC,MAAM3D,KAAKgJ,SAAS,wC,YARwB/D,S,2zBCH7BwI,E,0CAMnB,WAAYD,GAAS,MAGnB,IAHmB,sBACnB,gBANFA,QAAU,MAQkB,KAAtB,IAAAE,UAASF,GACX,MAAM,IAAIjL,UAAU,+BAJH,OAOnB,EAAKiL,QAAUA,EAPI,E,sDAeZ7J,GACP,IAAK3D,KAAKwN,QAAQlJ,KAAKX,GACrB,MAAM3D,KAAKgJ,SAAL,qCAA4ChJ,KAAKwN,QAAQ7I,iB,YAvBlBM,S,w2BCF9B4F,E,0CAGnB,aAAc,mCACZ,gBAHF3G,KAAOuH,OAIL,EAAK/F,aAAe,IAAIiI,UACxB,EAAK/H,aAAe,EAAKF,aAHb,E,oDAWE,2BAARmD,EAAQ,yBAARA,EAAQ,gBACd,IAAMhC,GAAW,EAAH,WAAO8B,UAAgBE,GAIrC,OAFA7I,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,gCASQ,2BAANkH,EAAM,yBAANA,EAAM,gBACf,GAAoB,IAAhBA,EAAKvE,OACP,MAAM,IAAIwE,MAAM,yCAFH,IAKR9F,EAAc6F,EALN,GAKD/B,EAAO+B,EALN,GAcf,OAPAlH,KAAK6F,cAAgB,CACnBV,MACA9D,QACAyE,QAAQ,EACRC,QAAQ,GAGH/F,S,YA1CgCwF,S,2zBCKtBmI,E,iKAMVhK,GAGP,KAAK,IAAAiK,WAAUjK,MAAS,IAAAS,eAAcT,GACpC,MAAM3D,KAAKgJ,SAAS,yC,YAVyB/D,S,s4BCG3ChD,EAAmBnB,OAAOkB,UAA1BC,eAEa8I,E,0CAMnB,WAAYD,GAAQ,MAOlB,IAPkB,sBAClB,gBANF5G,KAAOuH,OAAK3J,OAKQ,EAJpBgJ,OAAS,KAIW,EAHpB+C,gBAAiB,EAGG,EAFpBC,gBAAiB,EAIf,EAAKpI,aAAe,IAAIqI,UACxB,EAAKnI,aAAe,EAAKF,cAIrB,IAAAsI,UAASlD,GAAS,CACpB,IAAMmD,EAAa,GAKnBnN,OAAOqD,KAAK2G,GAAQtD,SAAQ,SAAC7F,GACvBmJ,EAAOnJ,aAAgB6D,YACzByI,EAAWtM,GAAOmJ,EAAOnJ,OAG7B,EAAKmJ,OAASmD,EAlBE,S,4DA4BlB,OADAjO,KAAK6N,gBAAiB,EACf7N,O,qCAWP,OADAA,KAAK8N,gBAAiB,EACf9N,O,+BAWAoC,EAAK8L,EAAa3D,GAIzB,IAAKvK,KAAK2F,mBAAoB,IAAAvB,eAAchC,GAC1C,OAAOpC,KAAKmG,eAAe/D,GAG7B,IAKE,OAJApC,KAAKoG,UAAUhE,GACfpC,KAAKqG,cAAcjE,GACnBpC,KAAKsG,eAAelE,GAEbpC,KAAKmG,eAAenG,KAAKmO,kBAC9B/L,EACA8L,IAAgBzF,oBAAoB8B,OAAWxF,IAEjD,MAAOR,GACPvE,KAAKoO,kCAAkC7J,GACvC,IAAMiC,EAAcxG,KAAKyG,eAAelC,EAAMa,SAE9C,GAAIoB,EACF,MAAMA,EAGR,MAAMjC,K,wCAaQnC,GAAoB,WAAfmI,EAAe,uDAAJ,GAChC,GAAoB,OAAhBvK,KAAK8K,OACP,OAAO1I,EAGT,IAAMqI,EAAS,GACT4D,EAAQ9D,EACRpG,EAAOrD,OAAOqD,KAAKnE,KAAK8K,QAgC9B,OA9BA3G,EAAKqD,SAAQ,SAAC7F,GACG,EAAKmJ,OAAOnJ,GAEfgE,kBAAqB1D,EAAe1B,KAAK6B,EAAKT,GAMxD8I,EAAO9I,GAAO,EAAK2M,oBAAoBlM,EAAK,CAC1CT,MACA0M,UAPF,EAAKE,4BAA4B,CAC/B5M,MACA8I,cASDzK,KAAK6N,gBACR/M,OACGqD,KAAK/B,GACLoF,SAAQ,SAAC7F,GACR,IAAM6M,GAAqC,IAAvBrK,EAAKsK,SAAS9M,GAElC,GAAI6M,IAAgB,EAAKV,eACvB,MAAM,IAAItJ,UAAJ,mBAA+B7C,EAA/B,qBAGJ6M,IACF/D,EAAO9I,GAAOS,EAAIT,OAInB8I,I,0CAaWrI,EAAKsG,GAAS,IACxB/G,EAAe+G,EAAf/G,IAAK0M,EAAU3F,EAAV2F,MACPK,EAAS1O,KAAK8K,OAAOnJ,GACrBgN,EAAY,CAAEhN,MAAKuC,KAAM,QAE/B,IACE,OAAOwK,EAAOhI,SACZtE,EAAIT,GACJ8G,oBAFK,wBAIA4F,GAJA,CAKHM,KAGJ,MAAOpK,GACPvE,KAAKoO,kCAAkC7J,GACvC,IAAMqK,EAAc,IAAH,QAAO,qCAAcP,GAAd,CAAqBM,KAA5B,OAEjB,MAAM,IAAInK,UAAJ,UACDoK,GADC,OACarK,EAAMa,SACvB,CAAEV,OAAO,O,kDAcamK,GAAQ,IAC1BlN,EAAgBkN,EAAhBlN,IAAK8I,EAAWoE,EAAXpE,OAEPiE,EAAS1O,KAAK8K,OAAOnJ,GACvB+M,EAAO7I,cAAcC,SACvB2E,EAAO9I,GAAO+M,EAAOrH,2BAAsBtC,Q,GAzLPS,W,8DCf1C,IAAIsJ,EAAmB,EAAQ,IAM/BjP,EAAOD,QAJP,SAA4BuK,GAC1B,GAAIG,MAAMyE,QAAQ5E,GAAM,OAAO2E,EAAiB3E,K,cCClDtK,EAAOD,QAJP,SAA0BoP,GACxB,GAAsB,oBAAX7N,QAA0BA,OAAOyK,YAAY9K,OAAOkO,GAAO,OAAO1E,MAAM2E,KAAKD,K,gBCD1F,IAAIF,EAAmB,EAAQ,IAW/BjP,EAAOD,QATP,SAAqCiB,EAAGqO,GACtC,GAAKrO,EAAL,CACA,GAAiB,iBAANA,EAAgB,OAAOiO,EAAiBjO,EAAGqO,GACtD,IAAIrN,EAAIf,OAAOkB,UAAU2C,SAASpE,KAAKM,GAAGsO,MAAM,GAAI,GAEpD,MADU,WAANtN,GAAkBhB,EAAE0C,cAAa1B,EAAIhB,EAAE0C,YAAY5C,MAC7C,QAANkB,GAAqB,QAANA,EAAoByI,MAAM2E,KAAKpO,GACxC,cAANgB,GAAqB,2CAA2CyC,KAAKzC,GAAWiN,EAAiBjO,EAAGqO,QAAxG,K,cCJFrP,EAAOD,QAJP,WACE,MAAM,IAAI2C,UAAU,0I,6wBCSDwL,E,iKAMVpK,GACP,IAAI,IAAAqK,UAASrK,KAAQ,IAAAS,eAAcT,GACjC,OAAO,EAGT,MAAM3D,KAAKgJ,SAAS,wC,YAX0B/D,S,65BCQ7BgG,E,0CASnB,WAAYD,GAAY,mCACtB,gBATF9G,KAAOuH,OAAKlD,MAQY,EAPxByC,WAAa,KASX,EAAKtF,aAAe,IAAI0J,UACxB,EAAKxJ,aAAe,EAAKF,aAGrBsF,aAAsBxF,YACxB,EAAKwF,WAAaA,GAPE,E,iDAmBpBlB,EAAKF,GACP,IAAM/C,EAAW,IAAIgD,UAAkBC,EAAKF,GAI5C,OAFA5J,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,0BAWL2J,EAAKC,GACP,IAAM/C,EAAW,IAAI6C,UAAkBC,EAAKC,GAI5C,OAFA5J,KAAKyF,UAAUsB,KAAKF,GACpB7G,KAAK4F,aAAeiB,EACb7G,O,+BAUAuI,EAAO2F,EAAa3D,GAG3B,IAAKvK,KAAK2F,mBAAoB,IAAAvB,eAAcmE,GAC1C,OAAOvI,KAAKmG,eAAeoC,GAG7B,IAKE,OAJAvI,KAAKoG,UAAUmC,GACfvI,KAAKqG,cAAckC,GACnBvI,KAAKsG,eAAeiC,GAEbvI,KAAKmG,eAAenG,KAAKmO,kBAC9B5F,EACA2F,IAAgBzF,oBAAoB8B,OAAWxF,IAEjD,MAAOR,GACPvE,KAAKoO,kCAAkC7J,GACvC,IAAMiC,EAAcxG,KAAKyG,eAAelC,EAAMa,SAE9C,GAAIoB,EACF,MAAMA,EAGR,MAAMjC,K,wCAYQgE,GAAsB,WAAfgC,EAAe,uDAAJ,GAC5B8D,EAAQ9D,EACNS,EAAehL,KAAfgL,WAER,OAAIA,EACKzC,EAAM8G,KAAI,SAACC,EAAGC,GAAJ,OAAc,EAAKC,aAAa,CAC/CD,QACAhH,QACA8F,cAKJ,aAAW9F,K,mCAYAsG,GAAQ,IAEjBU,EAGEV,EAHFU,MACAhH,EAEEsG,EAFFtG,MACA8F,EACEQ,EADFR,MAEMrD,EAAehL,KAAfgL,WAER,IACE,OAAOA,EAAWtE,SAChB6B,EAAMgH,GACN9G,oBAFK,wBAGD4F,GAHC,CAGM,CAAEnK,KAAM,QAASvC,IAAK4N,MAEnC,MAAOhL,GACPvE,KAAKoO,kCAAkC7J,GACvC,IAAMoK,EAAY,CAChBzK,KAAM,QACNvC,IAAK4N,GAEDX,EAAc,IAAH,QAAO,qCAAcP,GAAd,CAAqBM,KAA5B,OAEjB,MAAM,IAAInK,UAAJ,UACDoK,GADC,OACarK,EAAMa,SACvB,CAAEV,OAAO,S,YAhJwBc,S,2zBCRpB4J,E,iKAMVzL,GAGP,KAAK,IAAAoL,SAAQpL,MAAS,IAAAS,eAAcT,GAClC,MAAM3D,KAAKgJ,SAAS,uC,YAVuB/D,S,ozBCJ5BmG,E,0CAMnB,aAAwB,6BACtB,gBANFD,QAAU,KAKc,2BAATA,EAAS,yBAATA,EAAS,gBAGtB,GAAuB,IAAnBA,EAAQxI,OACV,MAAM,IAAImG,WAAW,uCAJD,OAOtB,EAAKqC,QAAUA,EAPO,E,sDAefxH,GAGP,IAFA,IAAI8L,EAAa,KAERrP,EAAI,EAAGA,EAAIJ,KAAKmL,QAAQxI,OAAQvC,GAAK,EAC5C,IACE,OAAOJ,KAAKmL,QAAQ/K,GAAGsG,SAAS/C,GAChC,MAAOY,GACPkL,EAAalL,EAIjB,MAAMkL,M,YAhC+BjK,S","file":"racoon.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"racoon\"] = factory();\n\telse\n\t\troot[\"racoon\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 20);\n","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","var _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","import ValidateError from './validate-error';\n\nconst { toString } = Object.prototype;\n\nexport function getType(val) {\n  const str = toString.call(val);\n  return str.substring(8, str.length - 1);\n}\n\nexport function isUndefined(val) {\n  return val === undefined;\n}\n\nexport function isNull(val) {\n  return val === null;\n}\n\nexport function isNaN(val) {\n  return val !== val;\n}\n\nexport function isString(val) {\n  return typeof val === 'string';\n}\n\nexport function isNumber(val) {\n  return typeof val === 'number';\n}\n\nexport function isInt(val) {\n  return isNumber(val) && val % 1 === 0;\n}\n\nexport function isInfinity(val) {\n  return (\n    val === Number.POSITIVE_INFINITY\n    || val === Number.NEGATIVE_INFINITY\n  );\n}\n\nexport function isBoolean(val) {\n  return typeof val === 'boolean';\n}\n\nexport function isRegExp(val) {\n  return val instanceof RegExp;\n}\n\nexport function isObject(val) {\n  return getType(val) === 'Object';\n}\n\nexport function isArray(val) {\n  return getType(val) === 'Array';\n}\n\nexport function isNotRequired(val) {\n  return isUndefined(val) || isNull(val);\n}\n\nexport function isEmpty(val) {\n  const type = getType(val);\n\n  if (type === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n\n  if (type === 'Array') {\n    return val.length === 0;\n  }\n\n  return (\n    isNotRequired(val)\n    || isNaN(val)\n    || val === ''\n  );\n}\n\n/**\n * Check if the value is Function. AsyncFunction or GeneratorFunction will\n * return false.\n *\n * @param {*} val The value to check.\n */\nexport function isFunction(val) {\n  return getType(val) === 'Function';\n}\n\n/**\n * Detect string whether can be parsed to number by `Number('xxx')`.\n *\n * Special case:\n * When the detected string is empty or only includes white spaces, the string\n * can be parsed to zero although, but it won't be regarded as a parsable\n * string still.\n *\n * @param {string} val The detected string.\n * @returns {boolean}\n */\nexport function isStringNumber(val) {\n  if (/^\\s*$/.test(val)) {\n    return false;\n  }\n  return !isNaN(Number(val));\n}\n\n/**\n * Check the error is a customed ValidateError.\n *\n * @param {Error} error The error object to check.\n */\nexport function isCustomError(error) {\n  return error instanceof ValidateError && error.custom;\n}\n\n/**\n * Check the error is a final ValidateError.\n *\n * @param {Error} error The error object to check.\n */\nexport function isFinalError(error) {\n  return error instanceof ValidateError && error.final;\n}\n","/**\n * The base class of all restrict.\n */\n\nimport { isFunction, isString } from '../util/is';\nimport ValidateError from '../util/validate-error';\n\nexport default class RestrictBase {\n  // To custom the error message when restrict validate fail. The message field\n  // can be either a string or a function, when it's a function, the ctx field\n  // can specify execute context of message function.\n  errorConfig = {\n    ctx: null,\n    message: '',\n  }\n\n  /**\n   * set errorConfig\n   *\n   * @param {String|Function} message The message of error.\n   * @param {*} [ctx] The execute context when message is a function.\n   */\n  setErrorMessage(message, ctx) {\n    this.errorConfig = {\n      ctx,\n      message,\n    };\n  }\n\n  /**\n   * Get the final error message when validate fail.\n   *\n   * @param {String} originMessage The origin message that throwed by racoon.\n   * @returns {ValidateError}\n   */\n  getError(originMessage) {\n    const { message, ctx } = this.errorConfig;\n\n    if (isFunction(message)) {\n      return new ValidateError(\n        message.call(ctx, originMessage),\n        { custom: true },\n      );\n    }\n\n    if (message && isString(message)) {\n      return new ValidateError(\n        message,\n        { custom: true },\n      );\n    }\n\n    return new ValidateError(originMessage);\n  }\n}\n","/**\n * Base class for all schema classes.\n */\n\nimport {\n  isEmpty,\n  isNotRequired,\n  isNaN,\n  isString,\n  isFunction,\n  isFinalError,\n  isCustomError,\n} from '../util/is';\nimport ValidateError from '../util/validate-error';\nimport RestrictRequired from '../restrict/required';\nimport RestrictCustom from '../restrict/custom';\n\nexport default class SchemaBase {\n  restricts = [];\n  typeRestrict = null;\n  requiredRestrict = null;\n\n  // Save the last restrict that added to schema. This is for add custom error\n  // message by call error method.\n  lastRestrict = null;\n\n  // The config of default return value when detected is empty.\n  defaultConfig = {\n    enable: false,\n    strict: false,\n    ctx: null,\n    value: undefined,\n  };\n\n  // The config of return value's formatter. By default, this will not do any\n  // formatting. This can be setted by call `format` method.\n  formatterConfig = {\n    ctx: undefined,\n    formatter: val => val,\n  };\n\n  // The custom error message config for all restricts. This can be setted by\n  // call 'errorForAll` method.\n  errorForAllConfig = {\n    enable: false,\n    ctx: undefined,\n    message: '',\n  };\n\n  /**\n   * Validate value.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    // When it's not required, and the detected value is undefined or null, then it's no need\n    // to validate any more, just return default value or default value after formated.\n    if (!this.requiredRestrict && isNotRequired(val)) {\n      return this.getReturnValue(val);\n    }\n\n    try {\n      this.checkType(val);\n      this.checkRequired(val);\n      this.checkRestricts(val);\n\n      return this.getReturnValue(val);\n    } catch (error) {\n      if (isCustomError(error)) {\n        throw error;\n      }\n\n      const errorForAll = this.getErrorForAll(error.message);\n\n      if (errorForAll) {\n        throw errorForAll;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Validate value by silent. The deference from validate method is that validate method will\n   * throw an error when validate fail, but validateSilent will not.\n   *\n   * @param {*} val The detected value.\n   */\n  validateSilent(val) {\n    try {\n      return {\n        value: this.validate(val),\n      };\n    } catch (error) {\n      return {\n        error,\n        value: val,\n      };\n    }\n  }\n\n  /**\n   * Add a \"required\" restrict to schema.\n   *\n   * @param {Boolean} [strict] Whether enable strict mode. By default, the mode\n   * is non-strict. If you pass strict exactly true, it will enable strict mode.\n   */\n  required(strict) {\n    this.requiredRestrict = new RestrictRequired(strict);\n    this.lastRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  /**\n   * Add a \"custom\" restrict to schema.\n   *\n   * @param {Function} restrictFn The custom restrict callback function.\n   * @param {*}        [ctx]      The exec context of restrictFn.\n   */\n  custom(restrictFn, ctx) {\n    const restrict = new RestrictCustom(restrictFn, ctx);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Set custom error message for the last restrict added to schema.\n   *\n   * @param {String|Function} message The custom error message.\n   * @param {*}               ctx     The excute context when message is a function.\n   */\n  error(message, ctx) {\n    this.ensureMessageType(message);\n    this.lastRestrict.setErrorMessage(message, ctx);\n    return this;\n  }\n\n  /**\n   * Set custom error message for all restrict. The message setted by `error` method\n   * is priority to that setted by `errorForAll`.\n   *\n   * @param {String|Function} message The custom error message.\n   * @param {*}               ctx     The excute context when message is a function.\n   */\n  errorForAll(message, ctx) {\n    this.ensureMessageType(message);\n    this.errorForAllConfig = {\n      enable: true,\n      message,\n      ctx,\n    };\n\n    return this;\n  }\n\n  /**\n   * Set the default return value of validate when the detected value is empty.\n   *\n   * @param {*}       args[0] The default return value.\n   * @param {boolean} args[1] Whether to enable strict mode.\n   * @param {*}       args[2] The execute context of value when value is a function.\n   */\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('default arguments should not be empty');\n    }\n\n    const [value, strict, ctx] = args;\n    this.defaultConfig = {\n      ctx,\n      value,\n      enable: true,\n      strict: strict === true,\n    };\n\n    return this;\n  }\n\n  /**\n   * Format the return value of validate method.\n   *\n   * @param {Function} formatter The function that format the return value.\n   * @param {*}        [ctx]     The execute context of formatter.\n   */\n  format(formatter, ctx) {\n    if (typeof formatter !== 'function') {\n      throw new TypeError('`formatter` should be a type of function');\n    }\n\n    this.formatterConfig = {\n      ctx,\n      formatter,\n    };\n\n    return this;\n  }\n\n  /**\n   * Get the last return value of validate.\n   *\n   * @param {*} val The origin detected value.\n   */\n  getReturnValue(val) {\n    const { enable, strict } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n\n    if (enable && strict && isEmpty(val)) {\n      return formatter.call(\n        ctx,\n        this.getDefaultReturnValue(val),\n      );\n    }\n\n    return this.getReturnValueWithoutStrict(val);\n  }\n\n  /**\n   * Get the default return value of validate.\n   *\n   * @param {*} val The origin detected value.\n   */\n  getDefaultReturnValue(val) {\n    const { value, ctx } = this.defaultConfig;\n\n    if (typeof value === 'function') {\n      return value.call(ctx, val);\n    }\n\n    return value;\n  }\n\n  /**\n   * Get the error message for all restricts.\n   *\n   * @param {string} originalMessage The origin error message throwed by racoon.\n   */\n  getErrorForAll(originalMessage) {\n    const {\n      ctx,\n      enable,\n      message,\n    } = this.errorForAllConfig;\n\n    if (enable !== true) {\n      return null;\n    }\n\n    if (isFunction(message)) {\n      return new ValidateError(message.call(ctx, originalMessage));\n    }\n\n    return new ValidateError(message);\n  }\n\n  /**\n   * Check if the detected value's type is right.\n   *\n   * @param {*} val The detected value.\n   */\n  checkType(val) {\n    return this.typeRestrict.validate(val);\n  }\n\n  /**\n   * Check if the detected value meet \"required\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  checkRequired(val) {\n    if (!this.requiredRestrict) {\n      return true;\n    }\n\n    return this.requiredRestrict.validate(val);\n  }\n\n  /**\n   * Check all restricts for the detected value.\n   *\n   * @param {*} val The detected value\n   */\n  checkRestricts(val) {\n    this.restricts.forEach((restrict) => {\n      restrict.validate(val);\n    });\n    return true;\n  }\n\n  /**\n   * Throw error without key chain when:\n   * 1. The error is the final error, it's no need to add key chain.\n   * 2. Or the error is custom error, it should not to add key chain.\n   *\n   * @param {Error} error The origin error object.\n   */\n  throwErrorWithoutKeyChainIfNeeded(error) {\n    if (isFinalError(error)) {\n      throw error;\n    }\n\n    if (isCustomError(error)) {\n      throw new ValidateError(error.message, { final: true });\n    }\n  }\n\n  /**\n   * @private\n   * Check if message is a valid type.\n   *\n   * @param {*} message The message param user passed.\n   */\n  ensureMessageType(message) {\n    if (!isString(message) && !isFunction(message)) {\n      throw new TypeError('`message` should be a type of string or function');\n    }\n  }\n\n  /**\n   * @private\n   * Get the last return value of validate. This is for non-strict mode scene.\n   *\n   * @param {*} val The origin return value.\n   */\n  getReturnValueWithoutStrict(val) {\n    const { enable } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    let value = val;\n\n    // If there is a default return value, then format the default value and\n    // return it.\n    if (enable && (isNotRequired(val) || isNaN(val))) {\n      value = this.getDefaultReturnValue(val);\n    }\n\n    // Otherwise, format the origin return value and return it.\n    return formatter.call(ctx, value);\n  }\n}\n","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeReflectConstruct = require(\"./isNativeReflectConstruct\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;","export const TYPE = {\n  number: 'number',\n  string: 'string',\n  boolean: 'boolean',\n  object: 'object',\n  array: 'array',\n  any: 'any',\n};\n\nexport const useKeyChainSymbol = Symbol('#useKeyChainSymbol');\n","export default class ValidateError extends Error {\n  custom = false;\n  final = false;\n\n  constructor(message, options = {}) {\n    super(message);\n    const {\n      custom = false,\n      final = false,\n    } = options;\n\n    this.custom = custom;\n    this.final = final;\n  }\n\n  toString() {\n    return `Validate${super.toString()}`;\n  }\n}\n","/**\n * Restrict value to be some enum values.\n */\n\nimport RestrictBase from './base';\n\nexport default class RestrictEnum extends RestrictBase {\n  enumValues = null;\n\n  /**\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  constructor(...values) {\n    super();\n\n    if (values.length === 0) {\n      throw new RangeError('enum arguments should not be empty');\n    }\n\n    this.enumValues = values;\n  }\n\n  /**\n   * Check the detected value whether meets this \"enum\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.enumValues.indexOf(val) === -1) {\n      throw this.getError(`value should be one of ${JSON.stringify(this.enumValues)}`);\n    }\n  }\n}\n","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var superPropBase = require(\"./superPropBase\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;","/**\n * Restrict the max length of detected value. The detected value\n * can be string or array.\n */\n\nimport RestrictBase from './base';\nimport { isNumber } from '../util/is';\n\nexport default class RestrictLengthMax extends RestrictBase {\n  /**\n   * @param {Number}  max      The max length of detected value.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected value can be equal to max. When\n   * closed is exactly false, the interval will be opened.\n   */\n  constructor(max, closed) {\n    super();\n\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be a type of number');\n    }\n\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  /**\n   * Check the detected value whether meets this \"length-max\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.closed && val.length > this.max) {\n      throw this.getError(`value length should be less than or equal to ${this.max}`);\n    }\n\n    if (!this.closed && val.length >= this.max) {\n      throw this.getError(`value length should be less than ${this.max}`);\n    }\n\n    return true;\n  }\n}\n","/**\n * Restrict the min length of detected value. The detected value\n * can be string or array.\n */\n\nimport RestrictBase from './base';\nimport { isNumber } from '../util/is';\n\nexport default class RestrictLengthMin extends RestrictBase {\n  /**\n   * @param {Number}  min      The min length of detected value.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected value can be equal to min. When\n   * closed is exactly false, the interval will be opened.\n   */\n  constructor(min, closed) {\n    super();\n\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a type of number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  /**\n   * Check the detected value whether meets this \"length-min\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.closed && val.length < this.min) {\n      throw this.getError(`value length should be greater than or equal to ${this.min}`);\n    }\n\n    if (!this.closed && val.length <= this.min) {\n      throw this.getError(`value length should greater than ${this.min}`);\n    }\n\n    return true;\n  }\n}\n","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","/**\n * Get key chain string.\n * @example\n * const keyChainStr = getKeyStr([\n *   {\n *     type: 'prop',\n *     key: 'peoples',\n *   },\n *   {\n *     type: 'index',\n *     key: 2,\n *   },\n *   {\n *     type: 'prop',\n *     key: 'friend',\n *   },\n *   {\n *     type: 'prop',\n *     key: 'first name',\n *   },\n * ]);\n * assert(keyChainStr === 'peoples[0].friend[\\'first name\\']');\n *\n * @param {Array} keyChain Key chain list.\n */\nexport default function getKeyStr(keyChain) {\n  const propReg = /^[_$a-z][_$a-z\\d]*$/i;\n  let result = '';\n\n  keyChain.forEach(({ type, key }) => {\n    if (type === 'prop' && propReg.test(key)) {\n      if (result) {\n        result += `.${key}`;\n      } else {\n        result += key;\n      }\n    } else if (type === 'prop') {\n      result += `['${key}']`;\n    } else if (type === 'index') {\n      result += `[${key}]`;\n    }\n  });\n\n  return result;\n}\n","import {\n  SchemaAny,\n  SchemaNumber,\n  SchemaString,\n  SchemaBoolean,\n  SchemaObject,\n  SchemaArray,\n  SchemaMixed,\n} from './schema';\n\nexport function any() {\n  return new SchemaAny();\n}\n\nexport function number() {\n  return new SchemaNumber();\n}\n\nexport function string() {\n  return new SchemaString();\n}\n\nexport function boolean() {\n  return new SchemaBoolean();\n}\n\nexport function object(config) {\n  return new SchemaObject(config);\n}\n\nexport function array(itemSchema) {\n  return new SchemaArray(itemSchema);\n}\n\nexport function mixed(...schemas) {\n  return new SchemaMixed(...schemas);\n}\n\nexport default {\n  any,\n  number,\n  string,\n  boolean,\n  object,\n  array,\n  mixed,\n};\n","function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct;","/**\n * Class for any schema.\n */\n\nimport { TYPE } from '../util/constants';\nimport RestrictAnySchema from '../restrict/any-schema';\nimport RestrictAnyRequired from '../restrict/any-required';\nimport RestrictEnum from '../restrict/enum';\nimport SchemaBase from './base';\n\nexport default class SchemaAny extends SchemaBase {\n  type = TYPE.any;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictAnySchema();\n    this.lastRestrict = this.typeRestrict;\n  }\n\n  /**\n   * Add a \"required\" restrict to any schema.\n   *\n   * @param {Boolean} [strict] Whether enable strict mode. By default, the mode\n   * is non-strict. If you pass strict exactly true, it will enable strict mode.\n   */\n  required(strict) {\n    this.requiredRestrict = new RestrictAnyRequired(strict);\n    this.lastRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  /**\n   * Add an \"enum\" restrict to any schema.\n   *\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n}\n","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","/**\n * Restrict value to be any type, which means that it will not\n * restrict the type of value. So, the validate method return\n * true always.\n */\n\nimport RestrictBase from './base';\n\nexport default class RestrictAnySchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"any-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate() {\n    return true;\n  }\n}\n","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeFunction = require(\"./isNativeFunction\");\n\nvar construct = require(\"./construct\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;","function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction;","/**\n * This is for any schema, to estrict value to be non-empty. By default,\n * non-empty means the detected value cann't be undefined, null. When in\n * strict mode, the detected value cann't be undefined, null, empty-string,\n * empty-object or empty-array.\n */\n\nimport RestrictBase from './base';\nimport {\n  isNaN,\n  isEmpty,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictAnyRequired extends RestrictBase {\n  strict = false;\n\n  /**\n   * @param {Boolean} strict Whether to enable strict mode. By default, strict mode\n   * is disabled. If strict param is passed to exactly true, strict mode will be\n   * enabled.\n   */\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  /**\n   * Check the detected value whether meets this \"any-required\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    const { strict } = this;\n\n    // In non-strict mode, if the detected value is undefined, null or NaN, the\n    // validation will be fail.\n    if (!strict && (isNotRequired(val) || isNaN(val))) {\n      throw this.getError('value is required and should not be undefined/null/NaN');\n    }\n\n    if (strict === true && isEmpty(val)) {\n      throw this.getError('value is required and should not be empty');\n    }\n  }\n}\n","/**\n * Restrict the detected value to be non-empty. Non-empty means undefined,\n * null. When in strict mode, non-empty means undefined, null, empty-string,\n * empty-object, empty-array.\n */\n\nimport RestrictBase from './base';\nimport { isEmpty, isNotRequired } from '../util/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  /**\n   * @param {Boolean} [strict] Whether enable strict mode. By default, the mode\n   * is non-strict. If you pass strict exactly true, it will enable strict mode.\n   */\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  /**\n   * Check the detected value whether meets this \"required\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    const { strict } = this;\n\n    if (strict && isEmpty(val)) {\n      throw this.getError('value is required and should not be empty');\n    }\n\n    if (!strict && isNotRequired(val))  {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n  }\n}\n","/**\n * Restrict value by a custom callback function.\n */\n\nimport { isFunction, isString } from '../util/is';\nimport RestrictBase from './base';\n\nexport default class RestrictCustom extends RestrictBase {\n  ctx = null;\n  restrictFn = null;\n\n  /**\n   * If restrictFn throws an error or returns a string, the validation\n   * will be fail. The message of error or the returned string respect\n   * the error message of validation.\n   *\n   * @param {Function} restrictFn The custom restrict callback function.\n   * @param {*}        [ctx]      The exec context of restrictFn.\n   */\n  constructor(restrictFn, ctx) {\n    super();\n\n    if (isFunction(restrictFn) === false) {\n      throw new TypeError('`restrictFn` should be a type of function');\n    }\n\n    this.restrictFn = restrictFn;\n    this.ctx = ctx;\n  }\n\n  /**\n   * Check the detected value whether meets this \"custom\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    try {\n      const result = this.restrictFn.call(this.ctx, val);\n\n      // If restrictFn return a non-empty string, validation will be fail.\n      if (isString(result) && result) {\n        throw this.getError(result);\n      }\n    } catch (error) {\n      // If restrictFn throws an error, validation will be fail too. And\n      // then should throw a wrapped error.\n      throw this.getError(error.message);\n    }\n\n    return true;\n  }\n}\n","import {\n  isString,\n  isStringNumber,\n} from '../util/is';\nimport { TYPE } from '../util/constants';\nimport RestrictNumberSchema from '../restrict/number-schema';\nimport RestrictNumberRequired from '../restrict/number-required';\nimport RestrictEnum from '../restrict/enum';\nimport RestrictNumberMax from '../restrict/number-max';\nimport RestrictNumberMin from '../restrict/number-min';\nimport RestrictNumberInt from '../restrict/number-int';\nimport RestrictNumberEven from '../restrict/number-even';\nimport RestrictNumberOdd from '../restrict/number-odd';\nimport SchemaBase from './base';\n\nexport default class SchemaNumber extends SchemaBase {\n  type = TYPE.number;\n  isAllowString = false;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictNumberSchema();\n    this.lastRestrict = this.typeRestrict;\n  }\n\n  /**\n   * Set the default return value of validate when the detected value is empty.\n   *\n   * @param {*} args[0] The default return value.\n   * @param {*} args[1] The execute context of value when value is a function.\n   */\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('default arguments should not be empty');\n    }\n\n    const [value, ctx] = args;\n\n    this.defaultConfig = {\n      ctx,\n      value,\n      enable: true,\n      strict: false,\n    };\n\n    return this;\n  }\n\n  /**\n   * Add an \"enum\" restrict to boolean schema.\n   *\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"required\" restrict to number schema.\n   */\n  required() {\n    this.requiredRestrict = new RestrictNumberRequired();\n    this.lastRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  /**\n   * By default, number schema doesn't allow the detected value to be NaN. If\n   * allowNaN method is called, then NaN will be allowd.\n   */\n  allowNaN() {\n    this.typeRestrict.enableAllowNaN();\n    return this;\n  }\n\n  /**\n   * By default, number schema doesn't allow the detected value to be Infinity.\n   * If allowInfinity method is called, then Infinity will be allowd.\n   */\n  allowInfinity() {\n    this.typeRestrict.enableAllowInfinity();\n    return this;\n  }\n\n  /**\n   * By default, number schema doesn't allow the detected value to be number\n   * style string. For example, a string \"123\" is not allowed. If allowString\n   * method is called, then number schema will try to parse string to number.\n   */\n  allowString() {\n    this.isAllowString = true;\n    return this;\n  }\n\n  /**\n   * Add a \"min-number\" restrict for detected number.\n   *\n   * @param {Number}  min      The min value of detected number.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the value of the detected number can be equal to min. When\n   * closed is exactly false, the interval will be opened.\n   */\n  min(min, closed) {\n    const restrict = new RestrictNumberMin(min, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"max-number\" restrict to number schema.\n   *\n   * @param {Number}  max      The max value of detected number.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the value of the detected number can be equal to max. When\n   * closed is exactly false, the interval will be opened.\n   */\n  max(max, closed) {\n    const restrict = new RestrictNumberMax(max, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add an \"int-number\" restrict to number schema.\n   */\n  int() {\n    const restrict = new RestrictNumberInt();\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  even() {\n    const restrict = new RestrictNumberEven();\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  odd() {\n    const restrict = new RestrictNumberOdd();\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * @override\n   * Validate value.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    let value = val;\n\n    // If allowString is called, then preparse string to number.\n    if (\n      this.isAllowString\n      && isString(val)\n      && isStringNumber(val)\n    ) {\n      value = Number(val);\n    }\n\n    return super.validate(value);\n  }\n}\n","/**\n * Restrict value to be type of number.\n */\n\nimport RestrictBase from './base';\nimport {\n  isNaN,\n  isNumber,\n  isInfinity,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictNumberSchema extends RestrictBase {\n  // Whether the detected number is allowed to be NaN. By default, it's not allowd.\n  isAllowNaN = false;\n  // Whether the detected number is allowed to be Infinity or -Infinity, By default,\n  // is't not allowd.\n  isAllowInfinity = false;\n\n  /**\n   * Allow the detected number to be NaN.\n   */\n  enableAllowNaN() {\n    this.isAllowNaN = true;\n  }\n\n  /**\n   * Allow the detected number to be Infinity or -Infinity.\n   */\n  enableAllowInfinity() {\n    this.isAllowInfinity = true;\n  }\n\n  /**\n   * Check the detected value whether meets this \"number-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    const { isAllowNaN, isAllowInfinity } = this;\n\n    if (isNaN(val) && !isAllowNaN) {\n      throw this.getError('value is not allowed to be NaN');\n    }\n\n    if (isInfinity(val) && !isAllowInfinity) {\n      throw this.getError('value is not allowed to be Infinity');\n    }\n\n    if (!isNumber(val) && !isNotRequired(val)) {\n      throw this.getError('value should be a type of number');\n    }\n  }\n}\n","/**\n * This is for number, to restrict the detected number is non-empty,\n * which means it's not undefined, null or NaN. This is differet from\n * the \"required\" strict, the \"required\" strict is for non-number value.\n */\n\nimport RestrictBase from './base';\nimport { isNaN, isNotRequired } from '../util/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"number-required\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n\n    // If required restrict is added for number schema, then the detected value\n    // cann't be NaN.\n    if (isNaN(val)) {\n      throw this.getError('value is required and should not be NaN');\n    }\n  }\n}\n","/**\n * This is for number, to restrict the max value of the detected number.\n */\n\nimport RestrictBase from './base';\nimport { isNumber } from '../util/is';\n\nexport default class RestrictNumberMax extends RestrictBase {\n  /**\n   * @param {Number}  max      The max value of the detected number.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the\n   * interval is closed, which means the detected number can be equal to max.\n   * When closed is exactly false, the interval will be opened.\n   */\n  constructor(max, closed) {\n    super();\n\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be a type of number');\n    }\n\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  /**\n   * Check the detected value whether meets this \"number-max\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.closed && val > this.max) {\n      throw this.getError(`value should be less than or equal to ${this.max}`);\n    }\n\n    if (!this.closed && val >= this.max) {\n      throw this.getError(`value should be less than ${this.max}`);\n    }\n  }\n}\n","/**\n * This is for number, to restrict the min value of the detected number.\n */\n\nimport RestrictBase from './base';\nimport { isNumber } from '../util/is';\n\nexport default class RestrictNumberMin extends RestrictBase {\n  /**\n   * @param {Number}  min      The min value of the detected number.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the\n   * interval is closed, which means the detected number can be equal to min.\n   * When closed is exactly false, the interval will be opened.\n   */\n  constructor(min, closed) {\n    super();\n\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a type of number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  /**\n   * Check the detected value whether meets this \"number-min\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (this.closed && val < this.min) {\n      throw this.getError(`value should be greater than or equal to ${this.min}`);\n    }\n\n    if (!this.closed && val <= this.min) {\n      throw this.getError(`value should be greater than ${this.min}`);\n    }\n  }\n}\n","/**\n * This is for number, to restrict the detected number to be\n * an integer.\n */\n\nimport RestrictBase from './base';\nimport { isInt } from '../util/is';\n\nexport default class RestrictNumberInt extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"number-int\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (isInt(val) === false) {\n      throw this.getError('value should be an integer');\n    }\n  }\n}\n","/**\n * This is for number, to restrict the detected number to be an even integer.\n */\n\nimport RestrictBase from './base';\n\nexport default class RestrictNumberEven extends RestrictBase {\n  /**\n   * Check the detected number whether meets this \"number-even\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (val % 2 !== 0) {\n      throw this.getError('value should be an even integer');\n    }\n  }\n}\n","/**\n * This is for number, to restrict the detected number to be an odd integer.\n */\n\nimport RestrictBase from './base';\n\nexport default class RestrictNumberOdd extends RestrictBase {\n  /**\n   * Check the detected number whether meets this \"number-odd\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (Math.abs(val) % 2 !== 1) {\n      throw this.getError('value should be an odd integer');\n    }\n  }\n}\n","import { TYPE } from '../util/constants';\nimport RestrictStringSchema from '../restrict/string-schema';\nimport RestrictEnum from '../restrict/enum';\nimport RestrictLengthMax from '../restrict/length-max';\nimport RestrictLengthMin from '../restrict/length-min';\nimport RestrictStringPattern from '../restrict/string-pattern';\nimport SchemaBase from './base';\n\nexport default class SchemaString extends SchemaBase {\n  type = TYPE.string;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictStringSchema();\n    this.lastRestrict = this.typeRestrict;\n  }\n\n  /**\n   * Add an \"enum\" restrict to string schema.\n   *\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"min-length\" restrict to string schema.\n   *\n   * @param {Number}  min      The min length of detected string.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected string can be equal to min. When\n   * closed is exactly false, the interval will be opened.\n   */\n  min(min, closed) {\n    const restrict = new RestrictLengthMin(min, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"max-length\" restrict to string schema.\n   *\n   * @param {Number}  max      The max length of detected string.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected string can be equal to max. When\n   * closed is exactly false, the interval will be opened.\n   */\n  max(max, closed) {\n    const restrict = new RestrictLengthMax(max, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"pattern\" string to string schema.\n   *\n   * @param {RegExp} pattern RegExp to restrict the format of string.\n   */\n  pattern(pattern) {\n    const restrict = new RestrictStringPattern(pattern);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n}\n","/**\n * Restrict value to be type of string.\n */\n\nimport RestrictBase from './base';\nimport {\n  isString,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictStringSchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"string-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (!isString(val) && !isNotRequired(val)) {\n      throw this.getError('value should be a type of string');\n    }\n  }\n}\n","/**\n * Restrict string format by a regular expression.\n */\n\nimport RestrictBase from './base';\nimport { isRegExp } from '../util/is';\n\nexport default class RestrictStringPattern extends RestrictBase {\n  pattern = null;\n\n  /**\n   * @param {RegExp} pattern The regular expression to restrict the format of string.\n   */\n  constructor(pattern) {\n    super();\n\n    if (isRegExp(pattern) === false) {\n      throw new TypeError('pattern should be an RegExp');\n    }\n\n    this.pattern = pattern;\n  }\n\n  /**\n   * Check the detected value whether meets this \"string-pattern\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (!this.pattern.test(val)) {\n      throw this.getError(`value should match pattern ${this.pattern.toString()}`);\n    }\n  }\n}\n","import { TYPE } from '../util/constants';\nimport RestrictBooleanSchema from '../restrict/boolean-schema';\nimport RestrictEnum from '../restrict/enum';\nimport SchemaBase from './base';\n\nexport default class SchemaBoolean extends SchemaBase {\n  type = TYPE;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictBooleanSchema();\n    this.lastRestrict = this.typeRestrict;\n  }\n\n  /**\n   * Add an \"enum\" restrict to boolean schema.\n   *\n   * @param {Array<*>} values The enum values that restrict the detected value can be.\n   */\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Set the default return value of validate when the detected value is empty.\n   *\n   * @param {*} args[0] The default return value.\n   * @param {*} args[1] The execute context of value when value is a function.\n   */\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('default arguments should not be empty');\n    }\n\n    const [value, ctx] = args;\n\n    this.defaultConfig = {\n      ctx,\n      value,\n      enable: true,\n      strict: false,\n    };\n\n    return this;\n  }\n}\n","/**\n * Restrict value to be type of boolean.\n */\n\nimport RestrictBase from './base';\nimport {\n  isBoolean,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictBooleanSchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"boolean-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    // When the detected value isn't boolean, null or undefined, validation\n    // will be fail. Otherwise, validation will be success.\n    if (!isBoolean(val) && !isNotRequired(val)) {\n      throw this.getError('value should be a type of boolean');\n    }\n  }\n}\n","import {\n  isObject,\n  isNotRequired,\n} from '../util/is';\nimport {\n  TYPE,\n  useKeyChainSymbol,\n} from '../util/constants';\nimport getKeyStr from '../util/get-key-str';\nimport RestrictObjectSchema from '../restrict/object-schema';\nimport ValidateError from '../util/validate-error';\nimport SchemaBase from './base';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport default class SchemaObject extends SchemaBase {\n  type = TYPE.object;\n  config = null;\n  isStripUnknown = false;\n  isAllowUnknown = false;\n\n  constructor(config) {\n    super();\n    this.typeRestrict = new RestrictObjectSchema();\n    this.lastRestrict = this.typeRestrict;\n\n    // If config is passed non-object, it means that the key-value structure\n    // is no need to restrct.\n    if (isObject(config)) {\n      const pureConfig = {};\n\n      // Filter the keys that corresponding value is an instance of SchemaBase.\n      // This is for the purpose that allow config include value that is not an\n      // instance of SchemaBase, and ingore them.\n      Object.keys(config).forEach((key) => {\n        if (config[key] instanceof SchemaBase) {\n          pureConfig[key] = config[key];\n        }\n      });\n      this.config = pureConfig;\n    }\n  }\n\n  /**\n   * If stripUnkown is called, then the return result of validate method will\n   * not include the keys that not included in config.\n   */\n  stripUnknown() {\n    this.isStripUnknown = true;\n    return this;\n  }\n\n  /**\n   * By default, the detected object is not allowed to include the unknown keys\n   * that is not included in config. If allowUnknown is called, then these\n   * unknown keys will be allowed, and these unknown key-values will be returned\n   * in validate result.\n   */\n  allowUnknown() {\n    this.isAllowUnknown = true;\n    return this;\n  }\n\n  /**\n   * Validate value.\n   *\n   * @param {*}      obj         The value to validate.\n   * @param {Symbol} useKeyChain If pass the special symbol, the keyChain param\n   * will be used.\n   * @param {Array}  keyChain    The passed key chain of parent keys.\n   */\n  validate(obj, useKeyChain, keyChain) {\n    // When it's not required, and the detected value is undefined or null,\n    // then it's no need to validate any more, just return default value or\n    // default value after formated.\n    if (!this.requiredRestrict && isNotRequired(obj)) {\n      return this.getReturnValue(obj);\n    }\n\n    try {\n      this.checkType(obj);\n      this.checkRequired(obj);\n      this.checkRestricts(obj);\n\n      return this.getReturnValue(this.validateByRecurse(\n        obj,\n        useKeyChain === useKeyChainSymbol ? keyChain : undefined,\n      ));\n    } catch (error) {\n      this.throwErrorWithoutKeyChainIfNeeded(error);\n      const errorForAll = this.getErrorForAll(error.message);\n\n      if (errorForAll) {\n        throw errorForAll;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * @private\n   * Traverse each key of the object and validate each value recursively.\n   *\n   * @param {Array} obj           The detected object.\n   * @param {Array} [keyChain=[]] The key chain of ancestors to give friendly\n   * error prompts.\n   * @returns {Object}            The return value if validate pass.\n   */\n  validateByRecurse(obj, keyChain = []) {\n    if (this.config === null) {\n      return obj;\n    }\n\n    const result = {};\n    const chain = keyChain;\n    const keys = Object.keys(this.config);\n\n    keys.forEach((key) => {\n      const schema = this.config[key];\n\n      if (!schema.requiredRestrict && !hasOwnProperty.call(obj, key)) {\n        this.setResultWhenDefaultEnabled({\n          key,\n          result,\n        });\n      } else {\n        result[key] = this.validateObjectByKey(obj, {\n          key,\n          chain,\n        });\n      }\n    });\n    if (!this.isStripUnknown) {\n      Object\n        .keys(obj)\n        .forEach((key) => {\n          const notIncluded = keys.includes(key) === false;\n\n          if (notIncluded && !this.isAllowUnknown) {\n            throw new ValidateError(`the key \\`${key}\\` is not allowed`);\n          }\n\n          if (notIncluded) {\n            result[key] = obj[key];\n          }\n        });\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   * Validate an key-value of the detected object.\n   *\n   * @param {object} obj            The detected object.\n   * @param {object} options\n   * @param {string} options.key    The prop key.\n   * @param {array}  options.chain  The key chain of ancestors to give friendly\n   * error prompts.\n   */\n  validateObjectByKey(obj, options) {\n    const { key, chain } = options;\n    const schema = this.config[key];\n    const keyOption = { key, type: 'prop' };\n\n    try {\n      return schema.validate(\n        obj[key],\n        useKeyChainSymbol,\n        [\n          ...chain,\n          keyOption,\n        ],\n      );\n    } catch (error) {\n      this.throwErrorWithoutKeyChainIfNeeded(error);\n      const keyChainStr = `\"${getKeyStr([...chain, keyOption])}\": `;\n\n      throw new ValidateError(\n        `${keyChainStr}${error.message}`,\n        { final: true },\n      );\n    }\n  }\n\n  /**\n   * @private\n   * Set some key-values of return value when default method was called.\n   *\n   * @param {object} params\n   * @param {string} params.key    The prop key.\n   * @param {object} params.result The value that will be returned.\n   * @returns {void}\n   */\n  setResultWhenDefaultEnabled(params) {\n    const { key, result } = params;\n\n    const schema = this.config[key];\n    if (schema.defaultConfig.enable) {\n      result[key] = schema.getDefaultReturnValue(undefined);\n    }\n  }\n}\n","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;","/**\n * Restrict value to be type of object.\n */\n\nimport RestrictBase from './base';\nimport {\n  isObject,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictObjectSchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"object-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    if (isObject(val) || isNotRequired(val)) {\n      return true;\n    }\n\n    throw this.getError('value should be a type of object');\n  }\n}\n","/**\n * Class for array schema.\n */\n\nimport {\n  isNotRequired,\n} from '../util/is';\nimport {\n  TYPE,\n  useKeyChainSymbol,\n} from '../util/constants';\nimport getKeyStr from '../util/get-key-str';\nimport ValidateError from '../util/validate-error';\nimport RestrictArraySchema from '../restrict/array-schema';\nimport RestrictLengthMin from '../restrict/length-min';\nimport RestrictLengthMax from '../restrict/length-max';\nimport SchemaBase from './base';\n\nexport default class SchemaArray extends SchemaBase {\n  type = TYPE.array;\n  itemSchema = null;\n\n  /**\n   * @param {SchemaBase} itemSchema The schema defined for every item of array.\n   * If itemSchema isn't instanceof SchemaBase, then it will be ignored, this\n   * means that the detected array can include any type value.\n   */\n  constructor(itemSchema) {\n    super();\n    this.typeRestrict = new RestrictArraySchema();\n    this.lastRestrict = this.typeRestrict;\n\n    // Only handle itemSchema when it's instanceof SchemaBase.\n    if (itemSchema instanceof SchemaBase) {\n      this.itemSchema = itemSchema;\n    }\n  }\n\n  /**\n   * Add a \"min-length\" restrict to array schema.\n   *\n   * @param {Number}  min      The min length of detected array.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected array can be equal to min. When\n   * closed is exactly false, the interval will be opened.\n   */\n  min(min, closed) {\n    const restrict = new RestrictLengthMin(min, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Add a \"max-length\" restrict to array schema.\n   *\n   * @param {Number}  max      The max length of detected array.\n   * @param {Boolean} [closed] Whether it's a closed interval. By default, the interval\n   * is closed, which means the length of the detected array can be equal to max. When\n   * closed is exactly false, the interval will be opened.\n   */\n  max(max, closed) {\n    const restrict = new RestrictLengthMax(max, closed);\n\n    this.restricts.push(restrict);\n    this.lastRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * Validate value.\n   *\n   * @param {*}      array       The value to validate.\n   * @param {Symbol} useKeyChain If pass the special symbol, the keyChain param will be used.\n   * @param {Array}  keyChain    The passed key chain of parent keys.\n   */\n  validate(array, useKeyChain, keyChain) {\n    // When it's not required, and the detected value is undefined or null, then it's no need\n    // to validate any more, just return default value or default value after formated.\n    if (!this.requiredRestrict && isNotRequired(array)) {\n      return this.getReturnValue(array);\n    }\n\n    try {\n      this.checkType(array);\n      this.checkRequired(array);\n      this.checkRestricts(array);\n\n      return this.getReturnValue(this.validateByRecurse(\n        array,\n        useKeyChain === useKeyChainSymbol ? keyChain : undefined,\n      ));\n    } catch (error) {\n      this.throwErrorWithoutKeyChainIfNeeded(error);\n      const errorForAll = this.getErrorForAll(error.message);\n\n      if (errorForAll) {\n        throw errorForAll;\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * @private\n   * Traverse each item of the array and validate each member recursively.\n   *\n   * @param {Array} array         The detected array.\n   * @param {Array} [keyChain=[]] The key chain of ancestors to give friendly error prompts.\n   * @returns {Array}             The return value if validate pass.\n   */\n  validateByRecurse(array, keyChain = []) {\n    const chain = keyChain;\n    const { itemSchema } = this;\n\n    if (itemSchema) {\n      return array.map((_, index) => this.validateItem({\n        index,\n        array,\n        chain,\n      }));\n    }\n\n    // Return a shallow copy of the detected array.\n    return [...array];\n  }\n\n  /**\n   * @private\n   * Validate an item of the detected array.\n   *\n   * @param {object} params\n   * @param {number} params.index  The index of the item in array.\n   * @param {array}  params.array  The detected array.\n   * @param {array}  params.chain  The key chain of ancestors.\n   */\n  validateItem(params) {\n    const {\n      index,\n      array,\n      chain,\n    } = params;\n    const { itemSchema } = this;\n\n    try {\n      return itemSchema.validate(\n        array[index],\n        useKeyChainSymbol,\n        [...chain, { type: 'index', key: index }],\n      );\n    } catch (error) {\n      this.throwErrorWithoutKeyChainIfNeeded(error);\n      const keyOption = {\n        type: 'index',\n        key: index,\n      };\n      const keyChainStr = `\"${getKeyStr([...chain, keyOption])}\": `;\n\n      throw new ValidateError(\n        `${keyChainStr}${error.message}`,\n        { final: true },\n      );\n    }\n  }\n}\n","/**\n * Restrict value to be type of array.\n */\n\nimport RestrictBase from './base';\nimport {\n  isArray,\n  isNotRequired,\n} from '../util/is';\n\nexport default class RestrictArraySchema extends RestrictBase {\n  /**\n   * Check the detected value whether meets this \"array-schema\" restrict.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    // When the detected value isn't array, null or undefined, validation\n    // will be fail. Otherwise, validation will be success.\n    if (!isArray(val) && !isNotRequired(val)) {\n      throw this.getError('value should be a type of array');\n    }\n  }\n}\n","/**\n * Mixed schema, it means you can combine several schemas into one schema.\n */\n\nimport SchemaBase from './base';\n\nexport default class SchemaMixed extends SchemaBase {\n  schemas = null;\n\n  /**\n   * @param {Array<SchemaBase>} schemas The allowed schemas.\n   */\n  constructor(...schemas) {\n    super();\n\n    if (schemas.length === 0) {\n      throw new RangeError('mixed arguments should not be empty');\n    }\n\n    this.schemas = schemas;\n  }\n\n  /**\n   * Validate value.\n   *\n   * @param {*} val The detected value.\n   */\n  validate(val) {\n    let finalError = null;\n\n    for (let i = 0; i < this.schemas.length; i += 1) {\n      try {\n        return this.schemas[i].validate(val);\n      } catch (error) {\n        finalError = error;\n      }\n    }\n\n    throw finalError;\n  }\n}\n"],"sourceRoot":""}