{"version":3,"file":"racoon.min.js","sources":["../lib/utils/is.js","../lib/utils/constants.js","../lib/utils/validate-error.js","../lib/restricts/base.js","../lib/restricts/number-type.js","../lib/restricts/number-required.js","../lib/restricts/enum.js","../lib/restricts/number-max.js","../lib/restricts/number-min.js","../lib/restricts/number-int.js","../lib/restricts/required.js","../lib/restricts/custom.js","../lib/type/base.js","../lib/type/number.js","../lib/restricts/string-type.js","../lib/restricts/length-max.js","../lib/restricts/length-min.js","../lib/restricts/string-pattern.js","../lib/type/string.js","../lib/restricts/boolean-type.js","../lib/type/boolean.js","../lib/restricts/any-type.js","../lib/restricts/any-required.js","../lib/type/any.js","../lib/restricts/object-type.js","../lib/type/object.js","../lib/restricts/array-type.js","../lib/type/arrary.js","../lib/index.js"],"sourcesContent":["export const toString = Object.prototype.toString;\n\nexport function getType(val) {\n  const str = toString.call(val);\n  return str.substring(8, str.length - 1);\n}\n\nexport function isUndefined(val) {\n  return getType(val) === 'Undefined';\n}\n\nexport function isNull(val) {\n  return val === null;\n}\n\nexport function isNaN(val) {\n  return val !== val;\n}\n\nexport function isNotRequired(val) {\n  return isUndefined(val) || isNull(val);\n}\n\nexport function isFalsy(val) {\n  return !val;\n}\n\nexport function isEmpty(val) {\n  const type = getType(val);\n  if (type === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n  if (type === 'Array' || type === 'Arguments') {\n    return val.length === 0;\n  }\n  return isFalsy(val);\n}\n\nexport function isEmptyObject(val) {\n  if (getType(val) === 'Object') {\n    return Object.keys(val).length === 0;\n  }\n  return false;\n}\n\nexport function isEmptyArray(val) {\n  if (getType(val) === 'Array') {\n    return val.length === 0;\n  }\n  return false;\n}\n\nexport function isString(val) {\n  return typeof val === 'string';\n}\n\nexport function isNumber(val) {\n  return typeof val === 'number';\n}\n\nexport function isInt(val) {\n  if (isNumber(val) === false) {\n    return false;\n  }\n  return Math.floor(val) === val;\n}\n\nexport function isInfinity(val) {\n  return isNumber(val) && isNaN(val) === false && Number.isFinite(val) === false;\n}\n\nexport function isBoolean(val) {\n  return typeof val === 'boolean';\n}\n\nexport function isRegExp(val) {\n  return val instanceof RegExp;\n}\n\nexport function isObject(val) {\n  return getType(val) === 'Object';\n}\n\nexport function isArray(val) {\n  return Array.isArray(val);\n}\n\nexport function isFunction(val) {\n  return getType(val) === 'Function';\n}\n\nexport function getKeyStr(keyChain) {\n  const propReg = /^[_$a-z][_$a-z\\d]*$/i;\n  let result = '';\n  for (let i = 0; i < keyChain.length; i += 1) {\n    const { type, key } = keyChain[i];\n    if (type === 'prop' && propReg.test(key)) {\n      if (result) {\n        result += `.${key}`;\n      } else {\n        result += key;\n      }\n    } else if (type === 'prop') {\n      result += `['${key}']`;\n    } else if (type === 'index') {\n      result += `[${key}]`;\n    }\n  }\n  return result;\n}\n","export const TYPE = {\n  number: 'number',\n  string: 'string',\n  boolean: 'boolean',\n  object: 'object',\n  array: 'array',\n  any: 'any'\n};\n","export default class ValidateError extends Error {\n  constructor(message, noKeyChain = false) {\n    super(message);\n    this.noKeyChain = noKeyChain;\n  }\n\n  toString() {\n    return `Validate${super.toString()}`;\n  }\n}\n","import { isFunction } from '../utils/is';\nimport ValidateError from '../utils/validate-error';\n\nexport default class RestrictBase {\n  errorConfig = {\n    message: '',\n    ctx: null\n  }\n\n  setErrorMessage(message, ctx) {\n    this.errorConfig = {\n      message,\n      ctx,\n    };\n  }\n\n  getError(originMessage) {\n    const { message, ctx } = this.errorConfig;\n    if (isFunction(message)) {\n      return new ValidateError(\n        message.call(ctx, originMessage),\n        true\n      );\n    }\n    if (message) {\n      return new ValidateError(message, true);\n    }\n    return new ValidateError(originMessage);\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isNaN,\n  isNumber,\n  isUndefined,\n  isNull,\n  isInfinity\n} from '../utils/is';\n\nexport default class RestrictNumberType extends RestrictBase {\n  isAllowNaN = false;\n  isAllowInfinity = false;\n\n  enableAllowNaN() {\n    this.isAllowNaN = true;\n  }\n\n  enableAllowInfinity() {\n    this.isAllowInfinity = true;\n  }\n\n  validate(val) {\n    const { isAllowNaN, isAllowInfinity } = this;\n    if (isNaN(val) && isAllowNaN === false) {\n      throw this.getError('value is not allowed to be NaN');\n    }\n    if (isInfinity(val) && isAllowInfinity === false) {\n      throw this.getError('value is not allowed to be Infinity');\n    }\n    if (isNumber(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof number');\n  }\n}\n","import RestrictBase from './base';\nimport { isNaN, isNotRequired } from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  validate(val) {\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n    if (isNaN(val)) {\n      throw this.getError('value is required and should not be NaN');\n    }\n    return true;\n  }\n}\n","import RestrictBase from './base';\n\nexport default class RestrictEnum extends RestrictBase {\n  enumValues = null;\n\n  constructor(...values) {\n    super();\n    if (values.length === 0) {\n      throw new RangeError('enum arguments can not be empty');\n    }\n    this.enumValues = values;\n  }\n\n  get valueStr() {\n    return JSON.stringify(this.enumValues);\n  }\n\n  validate(val) {\n    if (this.enumValues.indexOf(val) > -1) {\n      return true;\n    }\n    throw this.getError(`value should be one of ${this.valueStr}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictNumberMax extends RestrictBase {\n  constructor(max, closed) {\n    super();\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be typeof number');\n    }\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed === false) {\n      if (val < this.max) {\n        return true;\n      }\n      throw this.getError(`value should less than ${this.max}`);\n    }\n\n    if (val <= this.max) {\n      return true;\n    }\n    throw this.getError(`value should less than or equal ${this.max}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictNumberMin extends RestrictBase {\n  constructor(min, closed) {\n    super();\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed === false) {\n      if (val > this.min) {\n        return true;\n      }\n      throw this.getError(`value should greater than ${this.min}`);\n    }\n\n    if (val >= this.min) {\n      return true;\n    }\n    throw this.getError(`value should greater than or equal ${this.min}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isInt } from '../utils/is';\n\nexport default class RestrictNumberInt extends RestrictBase {\n  validate(val) {\n    if (isInt(val)) {\n      return true;\n    }\n    throw this.getError('value should be an int');\n  }\n}\n","import RestrictBase from './base';\nimport { isEmpty, isNotRequired } from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  validate(val) {\n    const { strict } = this;\n    if (strict === true) {\n      if (isEmpty(val)) {\n        throw this.getError('value is required and should not be empty');\n      }\n      return true;\n    }\n    if (isNotRequired(val)) {\n      throw this.getError('value is required and should not be undefined/null');\n    }\n    return true;\n  }\n}\n","import { isFunction } from '../utils/is';\nimport RestrictBase from './base';\n\nexport default class RestrictCustom extends RestrictBase {\n  constructor(restrictFn, ctx) {\n    super();\n    if (isFunction(restrictFn) === false) {\n      throw new TypeError('`custom` must receive a Function parameter');\n    }\n    this.restrictFn = restrictFn;\n    this.ctx = ctx;\n  }\n\n  validate(val) {\n    try {\n      this.restrictFn.call(this.ctx, val);\n    } catch (error) {\n      throw this.getError(error.message);\n    }\n    return true;\n  }\n}\n","import {\n  isEmpty,\n  isNotRequired,\n  isNaN\n} from '../utils/is';\nimport RestrictRequired from '../restricts/required';\nimport RestrictCustom from '../restricts/custom';\n\nexport default class TypeBase {\n  restricts = [];\n  typeRestrict = null;\n  requiredRestrict = null;\n  currentRestrict = null;\n  defaultConfig = {\n    enable: false,\n    strict: false,\n    value: undefined\n  };\n  formatterConfig = {\n    ctx: undefined,\n    formatter: val => val\n  };\n\n  required(strict = false) {\n    this.requiredRestrict = new RestrictRequired(strict);\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  custom(restrictFn, ctx) {\n    const restrict = new RestrictCustom(restrictFn, ctx);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  error(message, ctx) {\n    this.currentRestrict.setErrorMessage(message, ctx);\n    return this;\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, strict, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: strict === true,\n      value,\n      ctx\n    });\n    return this;\n  }\n\n  format(formatter, ctx) {\n    if (typeof formatter !== 'function') {\n      throw new TypeError('`format` argument should be a function');\n    }\n    this.formatterConfig = {\n      ctx,\n      formatter\n    };\n    return this;\n  }\n\n  calcDefaultValue(val) {\n    const { value, ctx } = this.defaultConfig;\n    if (typeof value === 'function') {\n      return value.call(ctx, val);\n    }\n    return value;\n  }\n\n  getReturnValueWithStrict(val) {\n    const { enable, strict } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    if (enable && (isNotRequired(val) || isNaN(val))) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    if (enable && isEmpty(val) && strict) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  getReturnValue(val) {\n    const { formatter, ctx } = this.formatterConfig;\n    if (this.defaultConfig.enable && (isNotRequired(val) || isNaN(val))) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  checkType(val) {\n    return this.typeRestrict.validate(val);\n  }\n\n  checkRequired(val) {\n    if (!this.requiredRestrict) {\n      return true;\n    }\n\n    return this.requiredRestrict.validate(val);\n  }\n\n  checkRestricts(val) {\n    for (let i = 0; i < this.restricts.length; i += 1) {\n      this.restricts[i].validate(val);\n    }\n    return true;\n  }\n\n  validate(val) {\n    if (!this.requiredRestrict && isNotRequired(val)) {\n      return this.getReturnValue(val);\n    }\n    this.checkType(val);\n    this.checkRequired(val);\n    this.checkRestricts(val);\n\n    return this.getReturnValue(val);\n  }\n\n  validateSilent(val) {\n    try {\n      return {\n        value: this.validate(val)\n      };\n    } catch (error) {\n      return {\n        error,\n        value: val\n      };\n    }\n  }\n}\n","import {\n  isNaN,\n  isNotRequired\n} from '../utils/is';\nimport { TYPE } from '../utils/constants';\nimport RestrictNumberType from '../restricts/number-type';\nimport RestrictNumberRequired from '../restricts/number-required';\nimport RestrictEnum from '../restricts/enum';\nimport RestrictNumberMax from '../restricts/number-max';\nimport RestrictNumberMin from '../restricts/number-min';\nimport RestrictNumberInt from '../restricts/number-int';\nimport TypeBase from './base';\n\nexport default class TypeNumber extends TypeBase {\n  type = TYPE.number;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictNumberType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    const { enable } = this.defaultConfig;\n    const { formatter, ctx } = this.formatterConfig;\n    if (\n      enable\n      && (isNotRequired(val) || isNaN(val))\n    ) {\n      return formatter.call(\n        ctx,\n        this.calcDefaultValue(val)\n      );\n    }\n    return formatter.call(ctx, val);\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: false,\n      value,\n      ctx\n    });\n    return this;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  required() {\n    this.requiredRestrict = new RestrictNumberRequired();\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  allowNaN() {\n    this.typeRestrict.enableAllowNaN();\n    return this;\n  }\n\n  allowInfinity() {\n    this.typeRestrict.enableAllowInfinity();\n    return this;\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictNumberMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictNumberMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  int() {\n    const restrict = new RestrictNumberInt();\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isString,\n  isNotRequired\n} from '../utils/is';\n\nexport default class RestrictStringType extends RestrictBase {\n  validate(val) {\n    if (isString(val) || isNotRequired(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof string');\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictLengthMax extends RestrictBase {\n  constructor(max, closed) {\n    super();\n    if (isNumber(max) === false) {\n      throw new TypeError('`max` should be typeof number');\n    }\n\n    this.max = max;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed) {\n      if (val.length <= this.max) {\n        return true;\n      }\n      throw this.getError(`value length should less than or equal ${this.max}`);\n    }\n    if (val.length < this.max) {\n      return true;\n    }\n    throw this.getError(`value length should less than ${this.max}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isNumber } from '../utils/is';\n\nexport default class RestrictLengthMin extends RestrictBase {\n  constructor(min, closed) {\n    super();\n    if (isNumber(min) === false) {\n      throw new TypeError('`min` should be a number');\n    }\n\n    this.min = min;\n    this.closed = closed !== false;\n  }\n\n  validate(val) {\n    if (this.closed) {\n      if (val.length >= this.min) {\n        return true;\n      }\n      throw this.getError(`value length should greater than or equal ${this.min}`);\n    }\n    if (val.length > this.min) {\n      return true;\n    }\n    throw this.getError(`value length should greater than ${this.min}`);\n  }\n}\n","import RestrictBase from './base';\nimport { isRegExp } from '../utils/is';\n\nexport default class RestrictStringPattern extends RestrictBase {\n  constructor(pattern) {\n    super();\n    if (isRegExp(pattern) === false) {\n      throw new TypeError('pattern should be a RegExp');\n    }\n    this.pattern = pattern;\n  }\n\n  validate(val) {\n    if (this.pattern.test(val)) {\n      return true;\n    }\n    throw this.getError(`value should match pattern ${this.pattern.toString()}`);\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictStringType from '../restricts/string-type';\nimport RestrictEnum from '../restricts/enum';\nimport RestrictLengthMax from '../restricts/length-max';\nimport RestrictLengthMin from '../restricts/length-min';\nimport RestrictStringPattern from '../restricts/string-pattern';\nimport TypeBase from './base';\n\nexport default class TypeString extends TypeBase {\n  type = TYPE.string;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictStringType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictLengthMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictLengthMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  pattern(pattern) {\n    const restrict = new RestrictStringPattern(pattern);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isBoolean,\n  isNotRequired\n} from '../utils/is';\n\nexport default class RestrictBooleanType extends RestrictBase {\n  validate(val) {\n    if (isBoolean(val) || isNotRequired(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof boolean');\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictBooleanType from '../restricts/boolean-type';\nimport RestrictEnum from '../restricts/enum';\nimport TypeBase from './base';\n\nexport default class TypeBoolean extends TypeBase {\n  type = TYPE;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictBooleanType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  default(...args) {\n    if (args.length === 0) {\n      throw new Error('`default` args can not be empty');\n    }\n    const [value, ctx] = args;\n    Object.assign(this.defaultConfig, {\n      enable: true,\n      strict: false,\n      value,\n      ctx\n    });\n    return this;\n  }\n}\n","import RestrictBase from './base';\n\nexport default class RestrictAnyType extends RestrictBase {\n  validate(val) {\n    return true;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isNaN,\n  isNotRequired,\n  isEmptyObject,\n  isEmptyArray\n} from '../utils/is';\n\nexport default class RestrictRequired extends RestrictBase {\n  strict = false;\n\n  constructor(strict) {\n    super();\n    this.strict = strict === true;\n  }\n\n  validate(val) {\n    const { strict } = this;\n    if (strict === true) {\n      if (\n        isNotRequired(val)\n        || val === ''\n        || isNaN(val)\n        || isEmptyObject(val)\n        || isEmptyArray(val)\n      ) {\n        throw this.getError('value is required and should not be empty');\n      }\n      return true;\n    }\n    if (isNotRequired(val) || isNaN(val)) {\n      throw this.getError('value is required and should not be undefined/null/NaN');\n    }\n    return true;\n  }\n}\n","import { TYPE } from '../utils/constants';\nimport RestrictAnyType from '../restricts/any-type';\nimport RestrictAnyRequired from '../restricts/any-required';\nimport RestrictEnum from '../restricts/enum';\nimport TypeBase from './base';\n\nexport default class TypeAny extends TypeBase {\n  type = TYPE.any;\n\n  constructor() {\n    super();\n    this.typeRestrict = new RestrictAnyType();\n    this.currentRestrict = this.typeRestrict;\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  required(strict = false) {\n    this.requiredRestrict = new RestrictAnyRequired(strict);\n    this.currentRestrict = this.requiredRestrict;\n    return this;\n  }\n\n  enum(...values) {\n    const restrict = new RestrictEnum(...values);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isObject,\n  isUndefined,\n  isNull\n} from '../utils/is';\n\nexport default class RestrictObjectType extends RestrictBase {\n  validate(val) {\n    if (isObject(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof object');\n  }\n}\n","import {\n  isObject,\n  isNotRequired,\n  getKeyStr,\n} from '../utils/is';\nimport { TYPE } from '../utils/constants';\nimport RestrictObjectType from '../restricts/object-type';\nimport ValidateError from '../utils/validate-error';\nimport TypeBase from './base';\n\nexport default class TypeObject extends TypeBase {\n  type = TYPE.object;\n  config = null;\n  isStripUnknown = false;\n  isAllowUnknown = false;\n\n  constructor(config) {\n    super();\n    this.typeRestrict = new RestrictObjectType();\n    this.currentRestrict = this.typeRestrict;\n    if (isObject(config)) {\n      const pureConfig = Object.create(null);\n      Object.keys(config).forEach(key => {\n        if (config[key] instanceof TypeBase) {\n          pureConfig[key] = config[key];\n        }\n      });\n      this.config = pureConfig;\n    }\n  }\n\n  get keys() {\n    return Object.keys(this.config);\n  }\n\n  hasKey(key) {\n    return this.keys.includes(key);\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  stripUnknown() {\n    this.isStripUnknown = true;\n    return this;\n  }\n\n  allowUnknown() {\n    this.isAllowUnknown = true;\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {Object} obj - object to validate\n   * @param {Array} [keyChain=[]] - object props chain\n   * @returns {Object} - result of validate\n   */\n  validateRecurse(obj, keyChain) {\n    keyChain = keyChain || [];\n\n    if (this.config === null) {\n      return obj;\n    }\n\n    const result = {};\n    let keys;\n    if (this.isStripUnknown === true) {\n      keys = this.keys;\n    } else {\n      keys = Object.keys(obj);\n    }\n    for (let i = 0; i < keys.length; i += 1) {\n      const key = keys[i];\n      const schema = this.config[key];\n      if (this.hasKey(key) === false) {\n        if (this.isAllowUnknown === true) {\n          result[key] = obj[key];\n          continue;\n        }\n        throw new ValidateError(`the key \\`${key}\\` is not allowed`);\n      }\n\n      try {\n        if (schema.type === TYPE.object || schema.type === TYPE.array) {\n          result[key] = schema.validateRecurse(\n            obj[key],\n            [\n              ...keyChain,\n              {\n                key,\n                type: 'prop'\n              }\n            ]\n          );\n        } else {\n          result[key] = schema.validate(obj[key]);\n        }\n      } catch (error) {\n        if (error instanceof ValidateError) {\n          if (error.noKeyChain) {\n            throw new Error(error.message);\n          }\n          let keyChainStr = getKeyStr([...keyChain, { type: 'prop', key }]);\n          keyChainStr = `\"${keyChainStr}\": `;\n          throw new Error(`${keyChainStr}${error.message}`);\n        } else {\n          throw error;\n        }\n      }\n    }\n    return result;\n  }\n\n  validate(obj) {\n    if (!this.requiredRestrict && isNotRequired(obj)) {\n      return this.getReturnValue(obj);\n    }\n    this.checkRequired(obj);\n    this.checkType(obj);\n    this.checkRestricts(obj);\n\n    return this.getReturnValue(\n      this.validateRecurse(obj)\n    );\n  }\n}\n","import RestrictBase from './base';\nimport {\n  isArray,\n  isUndefined,\n  isNull\n} from '../utils/is';\n\nexport default class RestrictArrayType extends RestrictBase {\n  validate(val) {\n    if (isArray(val) || isUndefined(val) || isNull(val)) {\n      return true;\n    }\n    throw this.getError('value should be typeof array');\n  }\n}\n","import {\n  isNotRequired,\n  getKeyStr,\n} from '../utils/is';\nimport ValidateError from '../utils/validate-error';\nimport { TYPE } from '../utils/constants';\nimport RestrictArrayType from '../restricts/array-type';\nimport RestrictLengthMin from '../restricts/length-min';\nimport RestrictLengthMax from '../restricts/length-max';\nimport TypeBase from './base';\n\nexport default class TypeArray extends TypeBase {\n  type = TYPE.array;\n  itemSchema = null;\n\n  constructor(itemSchema) {\n    super();\n    this.typeRestrict = new RestrictArrayType();\n    this.currentRestrict = this.typeRestrict;\n    if (itemSchema instanceof TypeBase) {\n      this.itemSchema = itemSchema;\n    }\n  }\n\n  getReturnValue(val) {\n    return this.getReturnValueWithStrict(val);\n  }\n\n  min(min, closed = true) {\n    const restrict = new RestrictLengthMin(min, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  max(max, closed = true) {\n    const restrict = new RestrictLengthMax(max, closed);\n    this.restricts.push(restrict);\n    this.currentRestrict = restrict;\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {Array} array - array to validate\n   * @param {Array} [keyChain=[]] - props key chain\n   * @returns {Array} - result of validate\n   */\n  validateRecurse(array, keyChain) {\n    keyChain = keyChain || [];\n    const { itemSchema } = this;\n\n    if (itemSchema) {\n      const result = [];\n      for (let i = 0; i < array.length; i += 1) {\n        try {\n          if (itemSchema.type === TYPE.array || itemSchema.type === TYPE.object) {\n            result.push(\n              itemSchema.validateRecurse(array[i], [...keyChain, { type: 'index', key: i }])\n            );\n          } else {\n            result.push(\n              itemSchema.validate(array[i])\n            );\n          }\n        } catch (error) {\n          if (error instanceof ValidateError) {\n            if (error.noKeyChain) {\n              throw new Error(error.message);\n            }\n            let keyChainStr = getKeyStr([...keyChain, { type: 'index', key: i }]);\n            keyChainStr = `\"${keyChainStr}\": `;\n            throw new Error(`${keyChainStr}${error.message}`);\n          } else {\n            throw error;\n          }\n        }\n      }\n      return result;\n    }\n    return array;\n  }\n\n  validate(array) {\n    if (!this.requiredRestrict && isNotRequired(array)) {\n      return this.getReturnValue(array);\n    }\n    this.checkRequired(array);\n    this.checkType(array);\n    this.checkRestricts(array);\n\n    return this.getReturnValue(\n      this.validateRecurse(array)\n    );\n  }\n}\n","import {\n  TypeNumber,\n  TypeString,\n  TypeBoolean,\n  TypeAny,\n  TypeObject,\n  TypeArray\n} from './type';\n\nexport function number() {\n  return new TypeNumber();\n}\n\nexport function string() {\n  return new TypeString();\n}\n\nexport function boolean() {\n  return new TypeBoolean();\n}\n\nexport function any() {\n  return new TypeAny();\n}\n\nexport function object(config) {\n  return new TypeObject(config);\n}\n\nexport function array(itemSchema) {\n  return new TypeArray(itemSchema);\n}\n\nexport default {\n  number,\n  string,\n  boolean,\n  any,\n  object,\n  array\n};\n"],"names":["toString","Object","prototype","getType","val","str","call","substring","length","isUndefined","isNull","isNaN","isNotRequired","isEmpty","type","keys","isFalsy","isNumber","isObject","isFunction","getKeyStr","keyChain","propReg","result","i","key","test","TYPE","number","string","object","array","any","ValidateError","message","noKeyChain","Error","RestrictBase","errorConfig","ctx","originMessage","this","RestrictNumberType","isAllowNaN","isAllowInfinity","getError","Number","isFinite","isInfinity","RestrictRequired","RestrictEnum","enumValues","values","RangeError","indexOf","valueStr","JSON","stringify","RestrictNumberMax","max","closed","TypeError","RestrictNumberMin","min","RestrictNumberInt","Math","floor","isInt","strict","RestrictCustom","restrictFn","error","TypeBase","restricts","typeRestrict","requiredRestrict","currentRestrict","defaultConfig","enable","value","undefined","formatterConfig","formatter","restrict","push","setErrorMessage","args","assign","calcDefaultValue","validate","checkType","checkRequired","checkRestricts","getReturnValue","TypeNumber","_this","RestrictNumberRequired","enableAllowNaN","enableAllowInfinity","RestrictStringType","isString","RestrictLengthMax","RestrictLengthMin","RestrictStringPattern","pattern","RegExp","TypeString","getReturnValueWithStrict","RestrictBooleanType","isBoolean","TypeBoolean","RestrictAnyType","isEmptyObject","isEmptyArray","TypeAny","RestrictAnyRequired","RestrictObjectType","TypeObject","config","isStripUnknown","isAllowUnknown","pureConfig","create","forEach","includes","obj","schema","hasKey","validateRecurse","keyChainStr","RestrictArrayType","Array","isArray","TypeArray","itemSchema","boolean"],"mappings":"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"}